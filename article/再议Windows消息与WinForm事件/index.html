<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        再议Windows消息与WinForm事件
    </h1>
</div>

    </header>
    <p class="article-date">2020-10-13</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/再议Windows消息与WinForm事件/#qian-yan">前言</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/再议Windows消息与WinForm事件/#xiao-xi-gai-shu">消息概述</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/再议Windows消息与WinForm事件/#chu-li-xiao-xi">处理消息</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/再议Windows消息与WinForm事件/#system-windows-forms-application">System.Windows.Forms.Application</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/再议Windows消息与WinForm事件/#wndproc">WndProc</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <h1 id="qian-yan">前言</h1>
<p>在2月份的时候，我之前曾经写过一篇关于Windows消息与C# WinForm事件机制的文章，名为《WinForm事件与消息》。在那篇文章中，我简单探讨了一下事件和消息。然而如今看来，当时的文章中的案例在运行上存在一定的问题，并且内容也有所缺陷，于是本文将重新优化文章的内容。</p>
<span id="continue-reading"></span><h1 id="xiao-xi-gai-shu">消息概述</h1>
<p>Windows下窗体应用程序的执行是通过消息驱动的。所有的外部事件，如键盘输入、鼠标移动、按动鼠标都由用户所触发；然后OS接收到对应的“消息”；然后送入消息队列中；接下来，启动的应用程序的工作引擎通过轮询等方式遍历获取，然后按照消息的类型逐个分发（Dispatch）到对应的组件（例如窗体、按钮等），最后才调用对应组件所注册的事件进行处理。</p>
<h1 id="chu-li-xiao-xi">处理消息</h1>
<p>一般来说，使用WinForm技术进行开发，绝大部分的情况下，我们都在做上述流程的最后一件事情：给各种控件注册事件。毕竟，WinForm真的为我们封装了绝大部分的事件了。而通常的WinForm开发，我们都离不开一个东西：System.Windows.Forms.Application。</p>
<h2 id="system-windows-forms-application">System.Windows.Forms.Application</h2>
<p>Application具有用于启动和停止应用程序和线程以及处理Windows消息的方法。例如，调用Run以启动当前线程上的应用程序消息循环，并可以选择使其窗体可见；调用Exit或ExitThread来停止消息循环。所以我们经常使用vs初始化一个基本的WinForm程序，显示的下列模板代码：</p>
<pre data-lang="C#" style="background-color:#2b303b;color:#c0c5ce;" class="language-C# "><code class="language-C#" data-lang="C#"><span style="color:#65737e;">/// &lt;</span><span style="color:#bf616a;">summary</span><span style="color:#65737e;">&gt;
</span><span style="color:#65737e;">/// 应用程序的主入口点。
</span><span style="color:#65737e;">/// &lt;/</span><span style="color:#bf616a;">summary</span><span style="color:#65737e;">&gt;
</span><span>[</span><span style="color:#bf616a;">STAThread</span><span>]
</span><span style="color:#b48ead;">static void </span><span style="color:#8fa1b3;">Main</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">Application</span><span>.</span><span style="color:#bf616a;">EnableVisualStyles</span><span>();
</span><span>    </span><span style="color:#bf616a;">Application</span><span>.</span><span style="color:#bf616a;">SetCompatibleTextRenderingDefault</span><span>(</span><span style="color:#d08770;">false</span><span>);
</span><span>    </span><span style="color:#bf616a;">Application</span><span>.</span><span style="color:#bf616a;">Run</span><span>(new Form1()); </span><span style="color:#65737e;">// 调用Run以启动当前线程上的应用程序消息循环
</span><span>}
</span></code></pre>
<p>因为Application是在单线程中运行的，所以在Application.Run开始后，Application本身不断轮询检查消息队列，然后根据消息类型进行数据分发。例如，当我们为这个Form1增加一个鼠标的点击事件后，我们运行该打开Form1：</p>
<pre data-lang="C#" style="background-color:#2b303b;color:#c0c5ce;" class="language-C# "><code class="language-C#" data-lang="C#"><span>Form1 </span><span style="color:#bf616a;">form1 </span><span>= new Form1();
</span><span style="color:#bf616a;">form1</span><span>.</span><span style="color:#bf616a;">MouseClick </span><span>+= 
</span><span>                (</span><span style="color:#bf616a;">sender</span><span>, </span><span style="color:#bf616a;">e</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">MessageBox</span><span>.</span><span style="color:#bf616a;">Show</span><span>(@&quot;</span><span style="color:#a3be8c;">MouseClick 1</span><span>&quot;);
</span><span style="color:#bf616a;">form1</span><span>.</span><span style="color:#bf616a;">MouseClick </span><span>+= 
</span><span>                (</span><span style="color:#bf616a;">sender</span><span>, </span><span style="color:#bf616a;">e</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">MessageBox</span><span>.</span><span style="color:#bf616a;">Show</span><span>(@&quot;</span><span style="color:#a3be8c;">MouseClick 2</span><span>&quot;);
</span><span style="color:#bf616a;">Application</span><span>.</span><span style="color:#bf616a;">Run</span><span>(</span><span style="color:#bf616a;">form1</span><span>);
</span></code></pre>
<p>运行后点击Form，可以看到首先出现一个MessageBox，展示“MouseClick 1”，我们点击确定后，又会出现MessageBox，展示“MouseClick 2”。实际上整个过程应该如下：</p>
<p>当我们按下鼠标左键后，消息形成并送往应用程序消息队列中，然后被Application类从应用程序消息队列中取出，然后分发到相应的窗体。窗体使用MouseClick事件中的函数指针调用已经添加的响应函数。所以C#中的事件字段实质上是一个函数指针列表，用来维护一些消息到达时的响应函数的地址。</p>
<p>到目前为止我们可以看到，消息其实在我们进行事件调用的时候，已经被提取加工了，它已经由Application进行了预处理，形成了所谓的“事件调用”。那么，我们还能更加自定义的干预消息吗？答案是可以的。</p>
<h2 id="wndproc">WndProc</h2>
<p>在.NET框架类库中的System.Windows.Forms命名空间中微软采用面对对象的方式重新定义了Message。该消息主要有一下的几个公共属性：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>System.Windows.Forms.Message
</span><span>HWnd     获取或设定消息的处理函数
</span><span>Msg      获取或设定消息的ID号
</span><span>Lparam   指定消息的LParam字段
</span><span>Wparam   指定消息的WParam字段
</span><span>Result   指定为响应消息处理函数而向OS系统返回的值
</span></code></pre>
<h3 id="wndproc-1">WndProc</h3>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>//
</span><span> // 摘要:
</span><span>//     处理 Windows 消息。
</span><span>//
</span><span>// 参数:
</span><span>//   m:
</span><span>//     要处理的 Windows System.Windows.Forms.Message。
</span><span>protected override void WndProc(ref System.Windows.Forms.Message e);
</span></code></pre>
<p>对于每个Form来说，我们都可以重写该方法，该方法的参数就是上面提到的Message类的实例，所有的消息在被获取后，正常情况下都会被封装为Message对象，然后由Application工作引擎调用对用的Form.WndProc传入该Messsage，由于Form子类重写了该方法，所以如果希望底层能处理相关的消息，需要通过base.WndProc传递到父类继续调用。下面就是一个代码示例来展示控制如果当前的消息是鼠标左键点击，则弹出MessageBox展示“WndProc MouseClick”：</p>
<pre data-lang="c#" style="background-color:#2b303b;color:#c0c5ce;" class="language-c# "><code class="language-c#" data-lang="c#"><span>        </span><span style="color:#b48ead;">protected </span><span>override </span><span style="color:#bf616a;">void WndProc</span><span>(</span><span style="color:#bf616a;">ref Message m</span><span style="background-color:#bf616a;color:#2b303b;">)</span><span>
</span><span>        {
</span><span>            </span><span style="color:#b48ead;">const int </span><span style="color:#bf616a;">WM_LBUTTONDOWN </span><span>= </span><span style="color:#d08770;">0x0201</span><span>;</span><span style="color:#65737e;">// 鼠标左键点击
</span><span>            </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">m</span><span>.</span><span style="color:#bf616a;">Msg </span><span>== </span><span style="color:#bf616a;">WM_LBUTTONDOWN</span><span>)
</span><span>            {
</span><span>                </span><span style="color:#bf616a;">MessageBox</span><span>.</span><span style="color:#bf616a;">Show</span><span>(&quot;</span><span style="color:#a3be8c;">WndProc MouseClick</span><span>&quot;);
</span><span>                </span><span style="color:#b48ead;">return</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#bf616a;">base</span><span>.</span><span style="color:#bf616a;">WndProc</span><span>(</span><span style="color:#b48ead;">ref </span><span style="color:#bf616a;">m</span><span>);
</span><span>        }
</span></code></pre>
<h3 id="imessagefilter">IMessageFilter</h3>
<p>除了上述的WndProc之外，其实更加便于处理应该的实现IMessageFilter接口，然后让Application将实现该接口的消息过滤器添加到Application中：</p>
<pre data-lang="c#" style="background-color:#2b303b;color:#c0c5ce;" class="language-c# "><code class="language-c#" data-lang="c#"><span>   </span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">MyMessageFilter </span><span style="color:#eff1f5;">: </span><span style="color:#a3be8c;">IMessageFilter
</span><span style="color:#eff1f5;">    {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">public bool </span><span style="color:#8fa1b3;">PreFilterMessage</span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">ref </span><span style="color:#eff1f5;">Message </span><span style="color:#bf616a;">m</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">        {
</span><span style="color:#eff1f5;">            </span><span style="color:#65737e;">//返回值为true， 表示消息已被处理，不要再往后传递，因此消息被截获
</span><span style="color:#eff1f5;">            </span><span style="color:#65737e;">//返回值为false，表示消息未被处理，需要再往后传递，因此消息未被截获
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">const int </span><span style="color:#bf616a;">WM_LBUTTONDOWN </span><span>= </span><span style="color:#d08770;">0x0201</span><span style="color:#eff1f5;">;</span><span style="color:#65737e;">// 鼠标左键点击
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">m</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">Msg </span><span>== </span><span style="color:#bf616a;">WM_LBUTTONDOWN</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">            {
</span><span style="color:#eff1f5;">                </span><span style="color:#bf616a;">MessageBox</span><span style="color:#eff1f5;">.</span><span style="color:#bf616a;">Show</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">MyMessageFilter MouseClick</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">                </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">    }
</span></code></pre>
<p>编写完成后，在应用程序初始化的过程中，添加该过滤器：</p>
<pre data-lang="C#" style="background-color:#2b303b;color:#c0c5ce;" class="language-C# "><code class="language-C#" data-lang="C#"><span style="color:#bf616a;">Application</span><span>.</span><span style="color:#bf616a;">AddMessageFilter</span><span>(new MyMessageFilter());
</span></code></pre>
<p>同样的，我们启动应用程序并点击实验，可以看到正常的MessageBox输出。</p>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>