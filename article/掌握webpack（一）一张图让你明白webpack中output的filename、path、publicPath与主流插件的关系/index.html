<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系
    </h1>
</div>

    </header>
    <p class="article-date">2022-12-31</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#ji-chu-huan-jing-da-jian">基础环境搭建</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#yin-ru-htmlwebpackplugin">引入HtmlWebpackPlugin</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#output-pathyu-output-filename">output.path与output.filename</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#yu-htmlwebpackpluginde-guan-lian">与HtmlWebpackPlugin的关联</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#guan-yu-output-filenamede-zhu-yi-dian">关于output.filename的注意点</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#output-publicpath">output.publicPath</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#yin-ru-minicssextractplugin">引入MiniCssExtractPlugin</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/掌握webpack（一）一张图让你明白webpack中output的filename、path、publicPath与主流插件的关系/#guan-yu-guan-xi-tu-de-bu-chong">关于关系图的补充</a>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <p>webpack的核心概念，放到2022年相信很多的小伙伴都已经非常清楚了。但是，对于webpack配置中的output.path、output.filename以及output.publicPath，还有很多小伙伴还不理解。本文讲围绕output.filename、output.path与output.publicPath，讲解它们的功能，并分析这些配置与webpack中常使用到的MiniCssExtractPlugin、HtmlWebpackPlugin等插件的关系。</p>
<span id="continue-reading"></span>
<p>直接上总结图</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/160-v3-path-filename-publicPath.png" alt="160-v3-path-filename-publicPath" /></p>
<h1 id="ji-chu-huan-jing-da-jian">基础环境搭建</h1>
<p>我们现在基于webpack搭建了一个前端项目，完成项目初始化，并安装webpack三件套：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>yarn init
</span><span>yarn add -D webpack webpack-cli webpack-dev-server
</span></code></pre>
<p>安装完成以后，我们在项目根目录下创建一个webpack.config.js，一个极简的配置如下：</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">const </span><span>{</span><span style="color:#bf616a;">resolve</span><span>} = </span><span style="color:#96b5b4;">require</span><span>(&#39;</span><span style="color:#a3be8c;">path</span><span>&#39;);
</span><span>module.exports = {
</span><span>    mode: &#39;</span><span style="color:#a3be8c;">development</span><span>&#39;,
</span><span>    entry: {
</span><span>        main: </span><span style="color:#8fa1b3;">resolve</span><span>(__dirname, &#39;</span><span style="color:#a3be8c;">src</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">index.js</span><span>&#39;)
</span><span>    },
</span><span>    output: {
</span><span>        filename: &#39;</span><span style="color:#a3be8c;">main.js</span><span>&#39;,
</span><span>        path: </span><span style="color:#8fa1b3;">resolve</span><span>(__dirname, &#39;</span><span style="color:#a3be8c;">dist</span><span>&#39;)
</span><span>    }
</span><span>}
</span></code></pre>
<p>然后，在package.json中添加脚本：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#a3be8c;">+ &quot;scripts&quot;: {
</span><span style="color:#a3be8c;">+   &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;
</span><span style="color:#a3be8c;">+ },
</span><span>  &quot;devDependencies&quot;: {
</span><span>    &quot;webpack&quot;: &quot;^5.75.0&quot;,
</span><span>    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;,
</span><span>    &quot;webpack-dev-server&quot;: &quot;^4.11.1&quot;
</span><span>  }
</span></code></pre>
<p>接着，我们在src目录下创建一个index.js文件，这个js文件的内容就是从dom上找到id为app的元素，并给其内部添加一个文本<code>"hello, world"</code>：</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span>document.</span><span style="color:#96b5b4;">getElementById</span><span>(&#39;</span><span style="color:#a3be8c;">app</span><span>&#39;).</span><span style="color:#bf616a;">innerText </span><span>= &#39;</span><span style="color:#a3be8c;">hello, world</span><span>&#39;
</span></code></pre>
<p>最后，我们运行webpack的构建过程：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>yarn build
</span></code></pre>
<p>运行以后，就会在项目根目录下的dist目录下生成main.js。</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/010-base-config.png" alt="010-base-config" /></p>
<p><em>注意：这里并没有配置关于js的解析，因为webpack默认就会处理js文件。</em></p>
<h2 id="yin-ru-htmlwebpackplugin">引入HtmlWebpackPlugin</h2>
<p>仅仅是生成目标js文件，可能还不是我们期望的效果。对于一个项目来说，我们通常还希望有一个html来展示UI，并运行js代码，但是手工创建可能不能是一个好的方案。这里，我们引入本项目的第一个插件：<strong>HtmlWebpackPlugin</strong>。</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>yarn add -D html-webpack-plugin
</span></code></pre>
<p>HtmlWebpackPlugin插件<strong>基础</strong>功能：</p>
<ol>
<li>它会使用一个模板来生成一个html；</li>
<li>在生成的html中插入节点（譬如，js对应的script节点等）。</li>
</ol>
<p>安装好该插件以后，在之前的webpack配置中，我们适当的修改：</p>
<ul>
<li>引用插件，并new一个HtmlWebpackPlugin实例（不添加其他配置）</li>
</ul>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span> const {resolve} = require(&#39;path&#39;);
</span><span style="color:#a3be8c;">+const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);
</span><span> module.exports = {
</span><span>     mode: &#39;development&#39;,
</span><span>     entry: {
</span><span>@@ -7,5 +8,10 @@ </span><span style="color:#8fa1b3;">module.exports = {
</span><span>     output: {
</span><span>         filename: &#39;main.js&#39;,
</span><span>         path: resolve(__dirname, &#39;dist&#39;)
</span><span style="color:#bf616a;">-    }
</span><span style="color:#a3be8c;">+    },
</span><span style="color:#a3be8c;">+    plugins: [
</span><span style="color:#a3be8c;">+        new HtmlWebpackPlugin({
</span><span style="color:#a3be8c;">+
</span><span style="color:#a3be8c;">+        })
</span><span style="color:#a3be8c;">+    ]
</span><span> }
</span><span>
</span></code></pre>
<p>让我们再次运行构建脚本后，我们会发现，dist目录中，不仅仅生成了main.js，还生成一个index.html：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/020-a-new-indexhtml.png" alt="020-a-new-indexhtml" /></p>
<p>通过检查这个index.html的内容可以看到，这个插件不仅仅帮我们生成了一个html，还在这个html中的head节点中创建了一个script节点，并且src属性填写的是main.js。</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/030-check-new-indexhtml.png" alt="030-check-new-indexhtml" /></p>
<p>此时，我们使用浏览器直接打开这个index.html，尽管是在文件系统，但浏览器还是可以通过script节点中的属性`src="main.js"，从index.html所在同级目录中加载main.js。然而，运行起来有报错：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/040-raw-indexhtml-script.png" alt="040-raw-indexhtml-script" /></p>
<blockquote>
<p>PS：这里有同学可能会认为是script节点在body以前加载的，所以会报错。但是实际不是这样的，这里script节点中有一个<code>defer</code>属性，这个属性表明，文档加载完毕以后才会执行main.js（<a rel="noopener" target="_blank" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script#attr-defer">MDN - defer</a>），所以，我们不用担心由于DOM未加载完就执行js代码而造成报错。</p>
</blockquote>
<p><strong>这个地方的问题在于：我们的main.js中会执行查找id为app的元素，但是实际生成的html是没有这个元素的。</strong></p>
<p>为了解决上述的问题，我们希望能够自定义生成index.html。通常的做法就是：</p>
<ol>
<li>在项目根目录创建一个public目录，在其中创建一个index.html（项目根目录/public/index.html），内容如下（重点是body里面添加了<code>&lt;div id="app"&gt;&lt;/div&gt;</code>）：</li>
</ol>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>&lt;!</span><span style="color:#b48ead;">DOCTYPE </span><span style="color:#d08770;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">html</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">charset</span><span>=&quot;</span><span style="color:#a3be8c;">utf-8</span><span>&quot;&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">title</span><span>&gt;这是一个模板HTML&lt;/</span><span style="color:#bf616a;">title</span><span>&gt;
</span><span>    &lt;</span><span style="color:#bf616a;">meta </span><span style="color:#d08770;">name</span><span>=&quot;</span><span style="color:#a3be8c;">viewport</span><span>&quot; </span><span style="color:#d08770;">content</span><span>=&quot;</span><span style="color:#a3be8c;">width=device-width, initial-scale=1</span><span>&quot;&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">head</span><span>&gt;
</span><span>&lt;</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>  &lt;</span><span style="color:#bf616a;">div </span><span style="color:#8fa1b3;">id</span><span>=&quot;</span><span style="color:#a3be8c;">app</span><span>&quot;&gt;
</span><span>  &lt;/</span><span style="color:#bf616a;">div</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">body</span><span>&gt;
</span><span>&lt;/</span><span style="color:#bf616a;">html</span><span>&gt;
</span></code></pre>
<ol start="2">
<li>然后，修改webpack配置中，关于HtmlWebpackPlugin的配置，配置插件<code>template</code>参数，表明使用上述的创建的index.html：</li>
</ol>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>     plugins: [
</span><span>         new HtmlWebpackPlugin({
</span><span style="color:#a3be8c;">+            template: resolve(__dirname, &#39;public&#39;, &#39;index.html&#39;)
</span><span>         })
</span><span>     ]
</span><span>
</span></code></pre>
<p>我们再次运行构建，可以看到在dist目录下的index.html是基于我们提供的模板生成：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/050-indexhtml-by-custom.png" alt="050-indexhtml-by-custom" /></p>
<p>此时，我们再次打开这个html，可以看到正确的处理后的结果：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/060-right-handle.png" alt="060-right-handle" /></p>
<h1 id="output-pathyu-output-filename">output.path与output.filename</h1>
<p>让我们回到关于output.path与output.filename上来。回顾我们的webpack配置：</p>
<ul>
<li>
<p>output.filename：确定js最终生成的文件名</p>
</li>
<li>
<p>output.path：确定js所在的根路径</p>
</li>
</ul>
<p>js最终生成的路径是：</p>
<p><code>output.path（绝对路径） + output.filename（文件名，可以有相对路径前缀）</code></p>
<p>做一个简单的实验便可知，例如，我们修改配置如下，把output.filename改为<code>"js/main.js"</code>，output.path改为<code>'resolve(__diranme, "my-dist")'</code>：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>     output: {
</span><span style="color:#bf616a;">-        filename: &#39;main.js&#39;,
</span><span style="color:#bf616a;">-        path: resolve(__dirname, &#39;dist&#39;)
</span><span style="color:#a3be8c;">+        filename: &#39;js/main.js&#39;,
</span><span style="color:#a3be8c;">+        path: resolve(__dirname, &#39;my-dist&#39;)
</span><span>     },
</span><span>
</span></code></pre>
<p>重新经过构建以后，我们会看到<code>my-dist</code>目录被创建，并且这个目录下面还会创建<code>js</code>目录，<code>js</code>目录中会有main.js，正好匹配了<code>output.path（项目根目录/my-dist） + output.filename（js/main.js）</code>。</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/070-new-output-path-and-filename.png" alt="070-new-output-path-and-filename" /></p>
<p>但是，output.filename与output.path仅仅影响js的生成吗？不然，让我看看这两个参数对于HtmlWebpackPlugin的关联关系。</p>
<h2 id="yu-htmlwebpackpluginde-guan-lian">与HtmlWebpackPlugin的关联</h2>
<p>对于上述生成结果，我们会注意到，在webpack配置中的HtmlWebpackPlugin插件部分，我们没有编写过任何关于index.html的生成路径的配置，但这个index.html最终也生成到了<code>"my-dist"</code>目录下（与output.path一致）；此外，我们还可以发现，生成的index.html里面的script节点的src属性，是<code>"js/mian.js"</code>（与output.filename一致）。</p>
<p>我们可以整理一个图，来描述相关配置与js构建、HtmlWebpackPlugin插件的关联关系：<img src="https://static-res.zhen.wang/images/post/2022-12-31/080-v1-path-filename.png" alt="080-v1-path-filename" /></p>
<p>总结来说，output.path与output.filename不能单纯只作为输出js的配置，HtmlWebpackPlugin也会使用它们：</p>
<ul>
<li>HtmlWebpackPlugin会使用<strong>output.path</strong> + <strong>插件本身的filename配置</strong>，作为html的生成路径；</li>
<li>HtmlWebpackPlugin会使用<strong>output.filename</strong>作为生成的html中script节点src属性的js路径（<strong>特别注意：这里还不准确，后续会补充修正！</strong>）。</li>
</ul>
<p>读者可以根据上述的表格，自己进行实验验证。</p>
<h2 id="guan-yu-output-filenamede-zhu-yi-dian">关于output.filename的注意点</h2>
<p>对于output.filename，需要注意的是，不能是一个绝对路径，譬如：<code>"/js/main.js" or "/main.js"</code>，一旦配置成了绝对路径，就会看到报错：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>configuration.output.filename: A relative path is expected. However, the provided value &quot;/js/main.js&quot; is an absolute path!
</span><span>   Please use output.path to specify absolute path and output.filename for the file name.
</span></code></pre>
<p>你只能写成：<code>"js/main.js"</code>或<code>"./js/main.js"</code>。然而，由于生成的html中script节点属性src的值，来源于这个output.filename值，如果我们有需求，希望生成的src等于一个绝对路径，譬如：<code>src="/js/main.js"</code>，仅仅靠output.filename是不行的。于是乎，output.publicPath就登场了！</p>
<h1 id="output-publicpath">output.publicPath</h1>
<p>首先，在webpack中，这个参数不配置的话，默认是空字符串<code>""</code>。然后，我们需要<strong>纠正我们前面的一个结论</strong>：</p>
<ul>
<li><del>HtmlWebpackPlugin会使用<strong>output.filename</strong>作为生成的html中script节点src属性的js路径</del></li>
</ul>
<p>实际上，script节点的src属性的路径，并不只是output.filename来决定的，而是由output.publicPath与output.filename共同决定：</p>
<p><code>src = output.publicPath（还有斜杠的特殊处理，后面讲）+ output.filename</code></p>
<p>只是因为output.publicPath默认是空字符串，所以我们前面生成出来的只是<code>src="js/main.js"</code>。这里，我们可以做一个简单的实验，配置publicPath为<code>"/"</code>，则生成的节点就会成为：<code>&lt;script src="/js/main.js"&gt;</code></p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/090-publicPath-root.png" alt="090-publicPath-root" /></p>
<p>output.publicPath: "abc"（尾部没有"/"），src="abc/js/main.js"：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/100-publicPath-abc.png" alt="100-publicPath-abc" /></p>
<p>output.publicPath: "/abc"（尾部依然没有"/"），src="/abc/js/main.js"：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/110-publicPath-root-abc.png" alt="110-publicPath-root-abc" /></p>
<p>仔细观察这几种场景，就可以知道HtmlWebpackPlugin插件，在生成html中的script标签时候，其中的src属性依赖output.filename以及output.publicPath，并且规则为：</p>
<ul>
<li>publicPath为空白字符串（默认），则src="${output.filename}"；</li>
<li>publicPath非空且不以"/"结尾，则src="${output.publicPath}/${output.filename}"（补充了一个"/"）；</li>
<li>publicPath非空且以"/"结尾，则src="${output.publicPath}${output.filename}"；</li>
</ul>
<p>需要注意的是，谨记js文件与html文件的生成不会受到output.publicPath的影响，只跟output.path和filename（js是output.filename，html是HtmlWebpackPlugin的filename）相关。</p>
<p>于是乎，我们重新整理前面的关系图，把output.publicPath配置引入：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/120-v2-path-filename-publicPath.png" alt="120-v2-path-filename-publicPath" /></p>
<p>细心的读者已经想到了，假如publicPath配置成了"/static/"，影响了HtmlWebpackPlugin中的script节点的src属性路径；而js文件实际生成路径仅受到output.path+output.filename，势必造成js访问路径不匹配的问题：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/130-path-not-match.png" alt="130-path-not-match.png" /></p>
<p>所以，日常对于webpack的配置一定要注意这种路径问题，保持匹配，否则使用webpack-dev-server就会出现问题～</p>
<p>相信看到这里，很多读者对output中的path、filename以及publicPath能够理解他们的效果了。接下来，我们举一反三，引入常用的CSS打包工具MiniCssExtractPlugin也来分析一下。</p>
<h1 id="yin-ru-minicssextractplugin">引入MiniCssExtractPlugin</h1>
<p>我们通常会有这样的需求，一个前端项目打包的时候，希望能够将项目依赖的css文件最终抽离为一个或N个css文件，并让我们的前端html直接以link节点的形式加载。这个时候，我们一般使用MiniCssExtractPlugin来完成这个需求。当然，除了这个插件以外，我们还需要一个最基础的loader：<code>css-loader</code>。</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>yarn add -D css-loader mini-css-extract-plugin
</span></code></pre>
<p>工程结构不会变化：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>项目根目录/
</span><span>├─ package.json
</span><span>├─ public
</span><span>│    └─ index.html
</span><span>├─ src
</span><span>│    └─ index.js
</span><span>└─ webpack.config.js
</span></code></pre>
<p>内容主要是新增了css-loader与mini-css-extract-plugin。</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/140-project-content.png" alt="140-project-content" /></p>
<p>接下来，我们编写一个简单的css样式文件存放于src目录下（src/my-style.css）：</p>
<pre data-lang="css" style="background-color:#2b303b;color:#c0c5ce;" class="language-css "><code class="language-css" data-lang="css"><span style="color:#bf616a;">body </span><span>{
</span><span>    background-color: aqua;
</span><span>}
</span><span>
</span><span style="color:#8fa1b3;">#app </span><span>{
</span><span>    background-color: azure;
</span><span>}
</span></code></pre>
<p>并修改index.js的代码，在index.js中引用它：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#a3be8c;">+import &#39;./my-style.css&#39;;
</span><span> document.getElementById(&#39;app&#39;).innerText = &#39;hello, world&#39;
</span></code></pre>
<p>此时，如果我们不进行任何的配置，运行webpack打包，会看到报错：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>ERROR in ./src/my-style.css 1:5
</span><span>Module parse failed: Unexpected token (1:5)
</span><span>You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
</span></code></pre>
<p>核心问题在于，webpack无法处理index.js中关于<code>.css</code>的文件（webpack默认值处理js文件）。所以，需要我们配置专门处理css的规则：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#a3be8c;">+ const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);
</span><span>module.exports = {
</span><span>      ... ...
</span><span>      plugins: [
</span><span>         new HtmlWebpackPlugin({
</span><span>             template: resolve(__dirname, &#39;public&#39;, &#39;index.html&#39;)
</span><span>         }),
</span><span style="color:#a3be8c;">+        new MiniCssExtractPlugin({
</span><span style="color:#a3be8c;">+            filename: &#39;css/main.css&#39;
</span><span style="color:#a3be8c;">+        })
</span><span>     ],
</span><span style="color:#a3be8c;">+    module: {
</span><span style="color:#a3be8c;">+        rules: [{
</span><span style="color:#a3be8c;">+            test: /\.css/,
</span><span style="color:#a3be8c;">+            use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;]
</span><span style="color:#a3be8c;">+        }]
</span><span style="color:#a3be8c;">+    }
</span><span>}
</span></code></pre>
<p>首先引入MiniCssExtractPlugin插件；然后在plugins中，new出MiniCssExtractPlugin插件实例，并传入filename配置<code>css/main.css</code>；最后，配置module.rules中，添加对css的处理：</p>
<blockquote>
<p>loader的执行顺序是按照数组从后向前的，所以use数组最后是css-loader，然后才是MiniCssExtractPlugin提供的loader。webpack在构建过程，遇到引用css的场景，则先调用css-loader，对css文件进行处理，然后调用MiniCssExtractPlugin提供的loader进行抽取</p>
</blockquote>
<p>完成配置以后，我们再次启动webpack的构建，会看到dist目录下，又会产生一个css目录，里面存放的就是mian.js，并且，检查index.html会发现这一次除了script标签外，还插入了link标签：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/150-css-output.png" alt="150-css-output" /></p>
<p>有的读者可能已经能够推断出，这个link标签的href路径，也是根据output.publicPath+MiniCssExtractPlugin插件的filename组合而来。这里直接给出结论，就是这样的。我们再次更新图表，把导出css样式文件的MiniCssExtractPlugin插件与相关的配置关系也总结进去，得到如下最终版关系图：</p>
<p><img src="https://static-res.zhen.wang/images/post/2022-12-31/160-v3-path-filename-publicPath.png" alt="160-v3-path-filename-publicPath" /></p>
<h1 id="guan-yu-guan-xi-tu-de-bu-chong">关于关系图的补充</h1>
<p>通过关系图，我们很容易知道，webpack中关于文件生成最核心的配置就是output.path以及各种filename，js的生成、css的生成、html的生成都依赖了这套配置；</p>
<p>其次，与js相关的output.filename和与css相关的MiniCssExtractPlugin.filename配置都有两个作用：</p>
<ol>
<li>js、css的生成文件路径；</li>
<li>被HtmlWebpackPlugin使用，以生成script节点和link节点中的资源路径（当然这个过程还有output.publicPath的参与）。</li>
</ol>
<p>最后，本文并没有讲到webpack-dev-server和上述配置的关系，这个会在本《掌握webpack》系列中单独出一期。</p>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>