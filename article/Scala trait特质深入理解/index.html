<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        Scala trait特质深入理解
    </h1>
</div>

    </header>
    <p class="article-date">2018-04-24</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/Scala trait特质深入理解/#chu-tan-scala-te-zhi-trait">初探Scala 特质trait</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/Scala trait特质深入理解/#javajie-kou-zhong-de-tong-ming-fang-fa">Java接口中的同名方法</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/Scala trait特质深入理解/#ji-xu-scalate-zhi-de-tao-lun">继续Scala特质的讨论</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/Scala trait特质深入理解/#shi-yong-te-zhi-lai-zuo-ke-dui-die-de-gai-dong-guo-lu">使用特质来做可堆叠的改动——过滤</a>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <h3 id="chu-tan-scala-te-zhi-trait">初探Scala 特质trait</h3>
<p>在Scala中，trait（特质）关键字有着举足轻重的作用。就像在Java中一样，我们只能在Scala中通过extends进行单一继承，但trait可以让我们从语义上实现了多重继承。通过对继承的类混入（mixin）多个特质，来达到多重继承的目的。乍一看，trait和Java中的interface接口很像，但是，细节上它们又有着大不同。</p>
<span id="continue-reading"></span><pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#65737e;">// 定义超类
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Super
</span><span style="color:#65737e;">// 定义特质
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> Trait
</span><span style="color:#65737e;">// 定义子类，将特质使用with关键字混入 Super 类，并继承之
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Sub </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Super </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">Trait
</span></code></pre>
<p>请务必体会上面的最后一条注释，早期学习的时候，我们往往容易将特质理解为Java中的接口，同时将with理解为Java中的implements，于是我们编写出如下的代码：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">A </span><span>with </span><span style="color:#ebcb8b;">T </span><span style="color:#65737e;">// 错误✖️
</span></code></pre>
<p>这样想是因为我们没有正确理解特质，特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类！即我们要明确，对于混入特质的子类定义，其实整体分为两个部分：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>[ class A ] extends [ S with T1 with T2 ...] 
</span></code></pre>
<p>中括号的表示两个部分才是正确的结构！</p>
<p>此外，与Java中的接口相比，我们还能够在特质中直接实现完整的方法，就像如下：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> TrMid1 </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In TrMid 1&#39;s f.</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>在Java8以前我们无法在接口中定义并实现完整的方法，而在Java8及以后我们可以通过default关键字来后面接完整的方法来实现。</p>
<p>现在，我们定义两个如下的特质：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> TrMid1 </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In TrMid 1&#39;s f.</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> TrMid2 </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In TrMid 2&#39;s f.</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>之后，我们定义一个名为Bottom的类，继承Scala中的Any类，同时混入上面定义的特质</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span>
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Bottom </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Any </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid1 </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid2
</span><span style="color:#65737e;">/* 
</span><span style="color:#65737e;">这里的Any是scala中的特殊对象
</span><span style="color:#65737e;">这里使用Any会报错
</span><span style="color:#65737e;">Error:(16, 31) illegal inheritance; superclass Any
</span><span style="color:#65737e;"> is not a subclass of the superclass Object
</span><span style="color:#65737e;"> of the mixin trait TrMid2
</span><span style="color:#65737e;">...
</span><span style="color:#65737e;">*/
</span></code></pre>
<p>“超类Any不是混入特质TrMid2的超类Object的子类”，即我们extends的类需要是Object的子类才行。面对上面的错误，我们可以将Any修改为AnyRef，这个类是scala内建类，本质上对应Java中的java.lang.Object类。修改之后，编译还是会报错：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span>...
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Bottom </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AnyRef </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid1 </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid2
</span><span>...
</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">Error:(16, 7) class Bottom inherits conflicting members:
</span><span style="color:#65737e;">  method f in trait TrMid2 of type =&gt; Unit  and
</span><span style="color:#65737e;">  method f in trait TrMid1 of type =&gt; Unit
</span><span style="color:#65737e;">(Note: this can be resolved by declaring an override in class Bottom.)
</span><span style="color:#65737e;">class Bottom extends AnyRef with TrMid2 with TrMid1 {
</span><span style="color:#65737e;">*/
</span></code></pre>
<p>这个错误提示我们在上面的两个特质中，均定义了相同签名的方法f，这里编译不通过，建议我们在Bottom类中实现f方法。换言之，当混入的多个特质中，分别定义了同名的方法，那么Scala会编译报错。在Java中也有类似的错误情形，下面就是关于Java，当然你可以跳过这一部分</p>
<hr />
<h4 id="javajie-kou-zhong-de-tong-ming-fang-fa">Java接口中的同名方法</h4>
<p>以上的讨论，务必与Java中区分开来，这里需要补充一下。在Java中，首先由于我们无法进行多重继承，我们只能编写形如这样的class AA extends BB implements CC, DD这样的代码，想要建立像上面的测试情形，我们还只能使用JDK8之后的能够在接口中使用default关键字来定义具有具体实现的方法，最终我们的代码如下：</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#65737e;">// [abstract] 为可选
</span><span>[</span><span style="color:#b48ead;">abstract</span><span>] </span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">BB </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">In BB&#39;s f()</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span>
</span><span style="color:#b48ead;">interface </span><span style="color:#ebcb8b;">CC </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// JDK8及以后的default关键字
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">default void </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">In CC&#39;s f()</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span>
</span><span style="color:#65737e;">// 测试类
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">AA </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">BB </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">CC </span><span style="color:#eff1f5;">{}
</span><span>
</span><span style="color:#65737e;">// 对比验证类，保证我们接口中的方法没问题
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">ZZ </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">CC </span><span style="color:#eff1f5;">{}
</span><span>
</span><span style="color:#b48ead;">public class </span><span style="color:#ebcb8b;">Test </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">public static void </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#ebcb8b;">String</span><span style="color:#b48ead;">[] </span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">AA</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">f</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// In BB&#39;s f()
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">ZZ</span><span style="color:#eff1f5;">().</span><span style="color:#bf616a;">f</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// In CC&#39;s f()，接口方法是没有问题的
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>根据上面的区别，我们首先确定是类似这样的class AA extends BB implements CC，同时BB，CC有同名的方法，Java中首先（只会？）找类中的实现。可能你有疑惑了，为什么不能够让多个接口都创建同名的默认方法，让一个类来实现它们，调用同名方法，就想这样：class AA implements CC, DD，遗憾的是（高兴的是？），当你这样做的时候，Java编译期就给你报错了啦！</p>
<pre data-lang="java" style="background-color:#2b303b;color:#c0c5ce;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">interface </span><span style="color:#ebcb8b;">CC </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">default void </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">In CC&#39;s f()</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">interface </span><span style="color:#ebcb8b;">DD </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">default void </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">() {
</span><span style="color:#eff1f5;">        </span><span style="color:#ebcb8b;">System</span><span style="color:#eff1f5;">.out.</span><span style="color:#bf616a;">println</span><span style="color:#eff1f5;">(</span><span>&quot;</span><span style="color:#a3be8c;">In DD&#39;s f()</span><span>&quot;</span><span style="color:#eff1f5;">);
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">AA </span><span style="color:#b48ead;">implements </span><span style="color:#a3be8c;">CC</span><span style="color:#eff1f5;">, </span><span style="color:#a3be8c;">DD </span><span style="color:#eff1f5;">{}
</span><span style="color:#65737e;">// 编译就会报错
</span><span style="color:#65737e;">// Error:(25, 1) java: 类 AA从类型 CC 和 DD 中继承了f() 的不相关默认值
</span></code></pre>
<p>要解决这个错误，要么，让其中一个接口中的同名方法改名，要么，实现类重写这个方法。</p>
<hr />
<h4 id="ji-xu-scalate-zhi-de-tao-lun">继续Scala特质的讨论</h4>
<p>上面的关于同名方法的报错曾提示我们，在底层类重写实现Bottom中的f方法。这是办法之一。但是，我们还有另一种方式。</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#65737e;">// 首先我们定义一个顶层的抽象类
</span><span style="color:#b48ead;">abstract class</span><span style="color:#ebcb8b;"> AbTop </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;"> </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit
</span><span style="color:#eff1f5;">}
</span><span style="color:#65737e;">// 让TrMid1、TrMid2均继承AbTop这个顶层抽象类，同时均重写抽象类中的方法
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> TrMid1 </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbTop </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In TrMid 1&#39;s f.</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> TrMid2 </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbTop </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In TrMid 2&#39;s f.</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span><span style="color:#65737e;">// Bottom类继承AbTop类并混入上面定义的两个特质
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Bottom </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbTop </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid1 </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid2 </span><span style="color:#eff1f5;">{}
</span><span style="color:#65737e;">// 进行测试
</span><span style="color:#b48ead;">object</span><span style="color:#ebcb8b;"> TraitTest </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">: </span><span style="color:#ebcb8b;">Array</span><span style="color:#eff1f5;">[</span><span style="color:#ebcb8b;">String</span><span style="color:#eff1f5;">]): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">val </span><span style="color:#bf616a;">top</span><span style="color:#eff1f5;">: </span><span style="color:#ebcb8b;">Bottom </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">Bottom
</span><span style="color:#eff1f5;">    top.f
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>我们编译运行这段程序，得到了如下的结果：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span>In TrMid </span><span style="color:#d08770;">2</span><span style="color:#a3be8c;">&#39;s</span><span> f.
</span></code></pre>
<p>首先我们可以确定，我们按照上面的类层级结构混入了两个带有同名方法f的特质，并没有像上面那样出现二义性错误；为什么会这样？让我们再次理解这一段话“特质是对我们要<strong>被继承</strong>的类的补充，是要混入我们要继承的类的，不是我们本身类”。也就是说，报错的那个二义性，是由于我们想要将两个同名的f方法混入AnyRef这个类中，然而，我们没有override关键字（也无法加上），那么混入过程只是单纯的向AnyRef类中添加两个签名一样的方法f，而语法上我们无法向同一个类中添加连个签名完全一样的方法，故报错；解决方法就是在我们的子类中override这个f方法，重写覆盖它，消除二选一。</p>
<p>而后者，我们能够编译运行还是像上面这样理解，由于我们是要向AbTop这个类中去混入特质，而我们每一个特质都是继承了AbTop类的，故我们应当重写覆盖顶层抽象类中的f方法，所以，在混入的过程中，从左到右每混入一次，他就加上一层外壳，所以这就是为什么，输出的结果是打印的第二个特质中f方法的输出，因为逐渐混入加壳的过程是从左到右的，先对AbTop加了壳，混入TrMid1特质，然后又对这一个结构加壳过程，混入TrMid2特质，就像下图：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/wrap.png" alt="wrap" />
这样一来，不难理解混入特质的过程（加壳的过程）本身就像一个一层一层继承的过程。还是上面那段带有AbTop的代码中，这一次我们添加一个新的抽象类AbNewTop，但是其中包含一个抽象方法其名称依然为f，然我们修改Bottom的定义：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">abstract class</span><span style="color:#ebcb8b;"> AbNewTop </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit
</span><span style="color:#eff1f5;">}
</span><span>...
</span><span>...
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Bottom </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbNewTop </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid2 </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">TrMid1 </span><span style="color:#eff1f5;">{}
</span><span>...
</span></code></pre>
<p>注意我们让Bottom不再继承AbTop，而是继承新定义的AbNewTop，其他诸如TrMid1依然继承的是AbTop不变。让我们运行代码，报错：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Error:(19, 36) illegal inheritance; superclass AbNewTop
</span><span> is not a subclass of the superclass AbTop
</span><span> of the mixin trait TrMid2
</span><span>class Bottom extends AbNewTop with TrMid2 with TrMid1 {
</span></code></pre>
<p>英语有点绕口，我们这里翻译并分割一下：“非法的继承；<em>超类AbNewTop</em> 不是 混入特质的TrMid2的 <em>超类AbTop</em> 的子类”。再次对应这个结构：[ class A ] extends [ S with T1 with T2 ...] 那么错误就在与后面的 S 与 T1、T2 对应不上了，及要实现正确的混入，S必须是T1、T2的超类的子类，当然，隐含的，本身也可以。转化为类图应该要满足如下的情形：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/class_map.png" alt="class_map" />
可能有些人有疑惑，为什么特质不继承自任何其他的类的时候，依然可以被混入到其他的类中，就像如下的形式：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> T1 </span><span style="color:#eff1f5;">{}
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Animal </span><span style="color:#eff1f5;">{}
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Dog </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Animal </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">T1 </span><span style="color:#eff1f5;">{}
</span></code></pre>
<p>因为在Scala任何的非值类（或特质）有默认的继承了scala.AnyRef类！这里的类图是如下的情形：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/animal_class.png" alt="animal_class" /></p>
<h3 id="shi-yong-te-zhi-lai-zuo-ke-dui-die-de-gai-dong-guo-lu">使用特质来做可堆叠的改动——过滤</h3>
<p>试想一种情形：现在有一个客户需要我们编写一种整形数字容器，这个容器的类似于Java中的List，我们可以往里面去添加数据，但是添加数据的过程是可过滤的，或者说可按条件进行预处理的。首先我们定义一个Container类：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Container  </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">private val </span><span style="color:#bf616a;">list</span><span style="color:#eff1f5;">: util.</span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">[</span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">] </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#eff1f5;">util.</span><span style="color:#ebcb8b;">ArrayList</span><span style="color:#eff1f5;">[</span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">]()
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">n</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">): </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> list.add(n)
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">idx</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">): </span><span style="color:#b48ead;">Int </span><span>=</span><span style="color:#eff1f5;"> list.get(idx)
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>目前为止，这个类似乎没什么特殊之处，甚至可以说是多此一举 —— 定义Container类的结构还不如直接使用一个util.ArrayList来的快。但是，试想一个场景，我现在要在添加之前 想要 首先检查这个是是否是偶数，如果不是，直接丢弃；如果是，则除以2再加入到容器中。如果仅仅使用现在的版本，你可能会直接在Container.add方法中去进行筛选，就像如下：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> Container </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">AbstractContainer </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">...
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">n</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(n % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) list.add(n / </span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">...
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>诚然，这段简单的代码的确能工作的很好。但是每一次的我改变规则，你难道就要在这个add代码中进行修改吗？亦或者假设这个类的源码根本就无法修改。你又如何操作？于是，使用特质来堆叠能够发挥作用：
首先我们还原add代码为最初始的状态，然后，我们定义如下的两个特质，并且定义我们的MyContainer类继承Container类并混入这两个特质：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> Even </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Container </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(x % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">.add(x)
</span><span style="color:#eff1f5;">}
</span><span>
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> Divide </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Container </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">add</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">x</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Int</span><span style="color:#eff1f5;">): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">.add(x / </span><span style="color:#d08770;">2</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span><span>
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> MyContainer </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">Container </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">Divide </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">Even
</span><span style="color:#65737e;">// 测试这段代码
</span><span style="color:#b48ead;">object</span><span style="color:#ebcb8b;"> Run </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">: </span><span style="color:#ebcb8b;">Array</span><span style="color:#eff1f5;">[</span><span style="color:#ebcb8b;">String</span><span style="color:#eff1f5;">]): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">val </span><span style="color:#bf616a;">myContainer </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">MyContainer
</span><span style="color:#eff1f5;">    myContainer.add(</span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    myContainer.add(</span><span style="color:#d08770;">6</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    println(myContainer.get(</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">)) </span><span style="color:#65737e;">// 输出3
</span><span style="color:#eff1f5;">    </span><span style="color:#65737e;">// println(myContainer.get(1)) // 超出边界
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}
</span></code></pre>
<p>在前面的讨论中我们知道，如果是一个类混入了多个特质，这多个特质含有同名的方法，会从左到右包装出来，即最终调用的是靠近右侧的实现了的方法。首先要实现筛选偶数，再除以2，最终添加到容器中。所以最先发挥作用的Even特质放在了最右侧。为什么这里，不仅能够筛选出偶数，同时还能除以2呢？答案就在super这个关键点。super.add即调用超类的add方法。这里再次用图来说明：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/evendivide.png" alt="evendivide" />
我想这个图足以说明了吧。调用过程就是先调用最右侧的Even.add方法，进行偶数筛选；然后调用超类super.add(x)；超类即从右到左开始Even左侧是Divide，Divide.add(x)，Divide.add内部对x除以2，传入super.add()方法，即再次向左侧，是Container.add()，此时接收到的数已经是除以2的数了：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/flow.png" alt="flow" />
还有一种情况是更为复杂的：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> A </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>=</span><span style="color:#eff1f5;"> println(</span><span>&quot;</span><span style="color:#a3be8c;">In A</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> B </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">A </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    println(</span><span>&quot;</span><span style="color:#a3be8c;">In B</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">.f
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">trait</span><span style="color:#ebcb8b;"> C </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">B </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">override def </span><span style="color:#8fa1b3;">f</span><span style="color:#eff1f5;">: </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    println(</span><span>&quot;</span><span style="color:#a3be8c;">In C</span><span>&quot;</span><span style="color:#eff1f5;">)
</span><span style="color:#eff1f5;">    </span><span style="color:#bf616a;">super</span><span style="color:#eff1f5;">.f
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}
</span><span style="color:#b48ead;">class</span><span style="color:#ebcb8b;"> T </span><span style="color:#b48ead;">extends </span><span style="color:#a3be8c;">A </span><span style="color:#b48ead;">with </span><span style="color:#a3be8c;">C
</span></code></pre>
<p>关系图对应如下：
<img src="https://static-res.zhen.wang/images/post/2018-04-24-trait/classrelation.png" alt="classrelation" />
输出：</p>
<pre data-lang="scala" style="background-color:#2b303b;color:#c0c5ce;" class="language-scala "><code class="language-scala" data-lang="scala"><span style="color:#b48ead;">object</span><span style="color:#ebcb8b;"> Run </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">  </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">main</span><span style="color:#eff1f5;">(</span><span style="color:#bf616a;">args</span><span style="color:#eff1f5;">: </span><span style="color:#ebcb8b;">Array</span><span style="color:#eff1f5;">[</span><span style="color:#ebcb8b;">String</span><span style="color:#eff1f5;">]): </span><span style="color:#b48ead;">Unit </span><span>= </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">val </span><span style="color:#bf616a;">t</span><span style="color:#eff1f5;">: </span><span style="color:#ebcb8b;">T </span><span>= </span><span style="color:#b48ead;">new </span><span style="color:#ebcb8b;">T
</span><span style="color:#eff1f5;">    t.f
</span><span style="color:#eff1f5;">  }
</span><span style="color:#eff1f5;">}
</span><span style="color:#65737e;">// 输出
</span><span>In C
</span><span>In B
</span><span>In A
</span></code></pre>
<p>看到输出，再根据前面的内容，我们也很容易理解，当某一个特质本生继承了其他的类的时候，super一定是其对应的超类，而不是class AA extends BB with TT中的BB这个类！</p>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>