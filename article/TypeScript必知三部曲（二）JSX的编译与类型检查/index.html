<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        TypeScript必知三部曲（二）JSX的编译与类型检查
    </h1>
</div>

    </header>
    <p class="article-date">2023-04-18</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#qian-yan-jsxbian-yi">前言：JSX编译</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#babelbian-yi-ti-xi">babel编译体系</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#tscbian-yi-ti-xi">tsc编译体系</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#zheng-wen-jsx-tsx-de-lei-xing-jian-cha">正文：JSX（TSX）的类型检查</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#zhun-bei-gong-zuo">准备工作</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#lei-xing-wen-ti">类型问题</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#lei-xing-jian-cha-de-yuan-tou-jsx-intrinsicelements">类型检查的源头：JSX.IntrinsicElements</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/TypeScript必知三部曲（二）JSX的编译与类型检查/#xie-zai-zui-hou">写在最后</a>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <p>在本三部曲系列的第一部中，我们介绍了TypeScript编译的两种方案(tsc编译、babel编译）以及二者的重要差异，同时分析了IDE是如何对TypeScript代码进行类型检查的。该部分基本涵盖了TypeScript代码编译的细节，但主要是关于TS代码本身的编译与类型检查。而本文，我们将着重讨论含有JSX的TypeScript代码（又称TSX）如何进行类型检查与代码编译的。</p>
<span id="continue-reading"></span><h1 id="qian-yan-jsxbian-yi">前言：JSX编译</h1>
<p>在介绍如何对JSX代码进行类型检查前，让我们花一点时间认识一下JSX，以及如何对其进行编译。</p>
<blockquote>
<p>注意：这块内容很多，如果读者已经熟悉这块的内容，可以直接从<strong>JSX（TSX）的类型检查</strong>开始阅读。</p>
</blockquote>
<p>实际上，JSX并不是合法有效的JS代码或HTML代码。目前为止也没有任何一家浏览器的引擎实现了对JSX的读取和解析。此外，JSX本身没有完全统一的规范，除了一些基本的规则以外，各种利用了JSX的JS库可以根据自身需求来设计JSX额外的特性。譬如，React中的元素会有className属性，而SolidJS中的元素会有classList属性。在FaceBook官方博文中也明确提到了：</p>
<blockquote>
<p>JSX是一种类似XML的语法扩展。它不打算由引擎或浏览器实现。它也不会作为某种提案被合并到ECMAScript规范中。它旨在被各种预处理器（转译器）用于将这些标记转换为标准的ECMAScript。—— <a rel="noopener" target="_blank" href="https://link.zhihu.com/?target=https%3A//facebook.github.io/jsx/%23sec-intro">JSX (facebook.github.io)</a></p>
</blockquote>
<p>当然，只要提到JSX我们就不得不提React，尽管React与JSX是相互独立的东西，但是React将JSX发扬光大，让更多的开发者接触到了JSX。所以我们先从React入手，分析JSX是如何编译为JS代码的。对于JSX的编译方案，已知的有两种：</p>
<ol>
<li>babel编译方案</li>
<li>tsc编译方案</li>
</ol>
<p>就像TypeScript编译一样，只要涉及到了编译环节，我们总是离不开编译三要素模型：源代码、编译器以及编译配置：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/010-code-compile-flow.png" alt="010-code-compile-flow" /></p>
<p>接下来将分别详细介绍这两种编译体系的编译过程。</p>
<h2 id="babelbian-yi-ti-xi">babel编译体系</h2>
<p>通过babel可以将结构化的JSX组件，转换为同样结构化的JS代码调用形式。在React中，转换JSX为原生JS代码分为两种形式：</p>
<ol>
<li>React17<strong>以前</strong>的<code>React.createElment</code>形式；</li>
<li>React17<strong>以后</strong>的<code>'react/jsx-runtime'</code>形式。</li>
</ol>
<p>先讲第一种：直接转换为<code>React.createElement</code>。假设源代码如下：</p>
<pre data-lang="tsx" style="background-color:#2b303b;color:#c0c5ce;" class="language-tsx "><code class="language-tsx" data-lang="tsx"><span style="color:#b48ead;">import </span><span style="color:#bf616a;">React </span><span style="color:#b48ead;">from </span><span>&#39;</span><span style="color:#a3be8c;">react</span><span>&#39;;
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">App</span><span>() {
</span><span>  </span><span style="color:#b48ead;">return </span><span>&lt;</span><span style="color:#bf616a;">h1</span><span>&gt;Hello World&lt;/</span><span style="color:#bf616a;">h1</span><span>&gt;;
</span><span>}
</span></code></pre>
<p>转换过程，会将上述JSX转换为如下的<code>createElement</code>代码：</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">import </span><span style="color:#bf616a;">React </span><span style="color:#b48ead;">from </span><span>&#39;</span><span style="color:#a3be8c;">react</span><span>&#39;;
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">App</span><span>() {
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">React</span><span>.</span><span style="color:#96b5b4;">createElement</span><span>(&#39;</span><span style="color:#a3be8c;">h1</span><span>&#39;, </span><span style="color:#d08770;">null</span><span>, &#39;</span><span style="color:#a3be8c;">Hello world</span><span>&#39;);
</span><span>}
</span></code></pre>
<p>但官方提到了关于这种转换方式的两个问题：</p>
<ul>
<li>如果使用 JSX，则需在 <code>React</code> 的环境下，因为 JSX 将被编译成 <code>React.createElement</code>，也就是说强绑定<code>React</code>。</li>
<li>有一些 <code>React.createElement</code> 无法做到的<a rel="noopener" target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md%23motivation">性能优化和简化</a>。</li>
</ul>
<p>基于上述的问题，在React17以后，提供了另一种转换方式：<strong>引入jsx-runtime层</strong>。假设源码如下：</p>
<pre data-lang="jsx" style="background-color:#2b303b;color:#c0c5ce;" class="language-jsx "><code class="language-jsx" data-lang="jsx"><span>function App() {
</span><span>  return &lt;h1&gt;Hello World&lt;/h1&gt;;
</span><span>}
</span></code></pre>
<p>下方是新 JSX 被转换编译后的结果：</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#65737e;">// 由编译器引入（禁止自己引入！）
</span><span style="color:#b48ead;">import </span><span>{</span><span style="color:#bf616a;">jsx </span><span style="color:#b48ead;">as </span><span style="color:#bf616a;">_jsx</span><span>} </span><span style="color:#b48ead;">from </span><span>&#39;</span><span style="color:#a3be8c;">react/jsx-runtime</span><span>&#39;;
</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">App</span><span>() {
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#8fa1b3;">_jsx</span><span>(&#39;</span><span style="color:#a3be8c;">h1</span><span>&#39;, { children: &#39;</span><span style="color:#a3be8c;">Hello world</span><span>&#39; });
</span><span>}
</span></code></pre>
<p>第二种模式的核心在于：JSX编译出来的代码与React库本身进行了解耦，只将JSX转换为了与React无关的JS形式的调用描述，没有直接使用<code>React.createElement</code>。**引入了jsx-runtime这一层，屏蔽具体的调用细节，只专注JSX到JS代码最基础的映射。**至于这个<code>_jsx</code>的具体实现，就是内部调用的是<code>React.createElement</code>还是另一种<code>createElement</code>，则可以由库内部来进行实现。</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/020-react-jsx-runtime.png" alt="020-react-jsx-runtime" /></p>
<blockquote>
<p>PS：可能有小伙伴会说，_jsx不还是从<code>react/jsx-runtime</code>这个React相关库导出的吗？实际上，这个包仅仅是由react团队在维护的原因。</p>
</blockquote>
<p>上图描述了一个前端React工程里JSX代码基本的转换思路。当然，Babel在这个转换过程中承担了重要角色。在Babel中，与上述两种转换相关的核心部分是：<code>@babel/preset-react</code>里面引用的插件<code>@babel/plugin-transform-react-jsx</code>。</p>
<p>Babel<code>v7.9.0</code>版本之前的该插件，只能将JSX代码转换为<code>React.createElement</code>调用形式。而在v7.9.0版本以后，支持我们配置转换行为。默认选项为 <code>{"runtime": "classic"}</code>，也就是说默认还是<code>React.createElement</code>。</p>
<p>如需启用新的转换，你可以使用 <code>{"runtime": "automatic"}</code> 作为 <code>@babel/plugin-transform-react-jsx</code> 或 <code>@babel/preset-react</code> 的选项：</p>
<pre data-lang="json" style="background-color:#2b303b;color:#c0c5ce;" class="language-json "><code class="language-json" data-lang="json"><span style="color:#65737e;">// 如果你使用的是 @babel/preset-react（内部引用了@babel/plugin-transform-react-jsx）
</span><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">presets</span><span>&quot;: [
</span><span>    [&quot;</span><span style="color:#a3be8c;">@babel/preset-react</span><span>&quot;, {
</span><span>      &quot;</span><span style="color:#a3be8c;">runtime</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">automatic</span><span>&quot;
</span><span>    }]
</span><span>  ]
</span><span>}
</span><span style="color:#65737e;">// 如果你使用的是 @babel/plugin-transform-react-jsx
</span><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">plugins</span><span>&quot;: [
</span><span>    [&quot;</span><span style="color:#a3be8c;">@babel/plugin-transform-react-jsx</span><span>&quot;, {
</span><span>      &quot;</span><span style="color:#a3be8c;">runtime</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">automatic</span><span>&quot;
</span><span>    }]
</span><span>  ]
</span><span>}
</span></code></pre>
<p>让我们创建一个样例<code>jsx-babel-example</code>，来实践上述过程。对应编译模型三要素，我们定义好如下的内容：</p>
<p>（1）源代码：src/index.jsx</p>
<pre data-lang="jsx" style="background-color:#2b303b;color:#c0c5ce;" class="language-jsx "><code class="language-jsx" data-lang="jsx"><span>const MyButton = (props) =&gt; &lt;button&gt;{props.children}&lt;/button&gt;
</span><span>
</span><span>function App() {
</span><span>    return &lt;h1&gt;&lt;MyButton&gt;Hello World&lt;/MyButton&gt;&lt;/h1&gt;;
</span><span>}
</span></code></pre>
<p>（2）babel编译器以及相关插件：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">yarn</span><span> add</span><span style="color:#bf616a;"> -D</span><span> @babel/core @babel/cli
</span><span style="color:#bf616a;">yarn</span><span> add</span><span style="color:#bf616a;"> -D</span><span> @babel/plugin-transform-react-jsx
</span></code></pre>
<p>（3）编译配置.babelrc：</p>
<pre data-lang="json" style="background-color:#2b303b;color:#c0c5ce;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">plugins</span><span>&quot;: [
</span><span>    [
</span><span>      &quot;</span><span style="color:#a3be8c;">@babel/plugin-transform-react-jsx</span><span>&quot;
</span><span>    ]
</span><span>  ]
</span><span>}
</span></code></pre>
<p>补充一个脚本：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>{
</span><span>  ...
</span><span style="color:#a3be8c;">+ &quot;scripts&quot;: {
</span><span style="color:#a3be8c;">+ 	 &quot;build&quot;: &quot;babel src -x .jsx --config-file ./.babelrc -d dist&quot;
</span><span style="color:#a3be8c;">+ },
</span><span>}
</span></code></pre>
<p>搭建完成以后，整体如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/030-jsx-babel-compile-project.png" alt="030-jsx-babel-compile-project" /></p>
<p>项目结构并不复杂，编译的过程我们也不再赘述。当我们运行<code>yarn build</code>的时候可以看到在dist目录下能够生成对应js代码：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/040-jsx-babel-compile-result.png" alt="040-jsx-babel-compile-result" /></p>
<p>从上图可以看到，我们的代码直接转换为了<code>React.createElement</code>。但是注意的是，编译结果中，babel是没有替我们插入<code>import React from 'react'</code>这一句代码的！如果你的代码本身没有添加<code>import React from 'react'</code>，那么最终编译到了js代码（无论是commonjs还是esmodule），也不会引入React，然而代码却调用的是：<code>React.createElement</code>。正是因为如此，所以才会有我们日常小伙伴会发现，项目能够编译通过，但是运行起来的时候，会提示：</p>
<p><em><strong>ReferenceError: React is not defined</strong></em></p>
<p>对于上面问题的解决办法，有两种方式解决：</p>
<p>方式一：在你的代码中手动写上：<code>import React from 'react'</code>。编译后，自然而然就有了<code>import React from 'react'</code>。</p>
<p>方式二：使用编译参数：<code>"runtime": "automatic"</code>：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>{
</span><span>  &quot;plugins&quot;: [
</span><span>    [
</span><span>      &quot;@babel/plugin-transform-react-jsx&quot;,
</span><span style="color:#a3be8c;">+     { &quot;runtime&quot;: &quot;automatic&quot; } 
</span><span>    ]
</span><span>  ]
</span><span>}
</span></code></pre>
<p>新增上述配置以后，重新编译代码，能够看到生产的js代码：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/050-jsx-babel-compile-with-automatic.png" alt="050-jsx-babel-compile-with-automatic" /></p>
<p>对于重新编译好的代码，此时可以看到<code>React.createElement</code>调用变为了来源于<code>"react/jsx-runtime"</code>中的<code>jsx</code>方法。同时，由于这一段引入是由<strong>编译器自动加入</strong>的，因此代码进行后续的babel编译的时候，由于有<code>react/jsx-runtime</code>的引入，所以就不再会有所谓的<code>React is not defined</code>的问题。</p>
<h2 id="tscbian-yi-ti-xi">tsc编译体系</h2>
<p>介绍完babel编译jsx体系以后，我们再讲一下关于tsc编译jsx代码的方式。当然，基于编译要素模型，我们依然准备一个项目来解释这个过程。</p>
<p>（1）源代码同上src/index.jsx。</p>
<p>（2）typescript包：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">yarn</span><span> add</span><span style="color:#bf616a;"> -D</span><span> typescript
</span></code></pre>
<p>（3）编译配置tsconfig.json：</p>
<pre data-lang="json" style="background-color:#2b303b;color:#c0c5ce;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">compilerOptions</span><span>&quot;: {
</span><span>    &quot;</span><span style="color:#a3be8c;">jsx</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">react</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">outDir</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">dist</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">rootDir</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">src</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">allowJs</span><span>&quot;: </span><span style="color:#d08770;">true
</span><span>  }
</span><span>}
</span></code></pre>
<p>补充一个脚本：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>{
</span><span>  ...
</span><span>  &quot;scripts&quot;: {
</span><span style="color:#a3be8c;">+ 	&quot;build&quot;: &quot;tsc -p tsconfig.json&quot;
</span><span>  },
</span><span>  ...
</span><span>}
</span><span>
</span></code></pre>
<p>搭建完成后，整体如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/060-jsx-tsc-compile-project.png" alt="060-jsx-tsc-compile-project" /></p>
<p>当我们运行<code>yarn build</code>的时候可以看到在dist目录下能够生成对应js代码：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/070-jsx-tsc-compile-result-by-jsxreact.png" alt="070-jsx-tsc-compile-result-by-jsxreact" /></p>
<p>读者应该能够看到由tsc编译出来的js代码，JSX相关的代码编译为了<code>React.createElement</code>形式的调用。对于这个编译结果，tsconfig.json里面的配置起到了决定性作用。现在，我们着重讲一下两个配置项：<code>jsx</code>、<code>allowJs</code>。</p>
<p><code>"allowJs"</code></p>
<p>由于本example中我们没有编写tsx代码，还是用的jsx代码，如果不配置<code>"allowJs": true</code>，那么tsc编译器默认将不会处理js以及jsx文件，又因为example中src目录下只有jsx文件，于是会出现报错：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>error TS18003: No inputs were found in config file &#39;/Users/w4ngzhen/projects/web-projects/jsx-tsc-example/tsconfig.json&#39;. Specified &#39;include&#39; paths were &#39;[&quot;**/*&quot;]&#39; and &#39;exclude&#39; paths were &#39;[&quot;dist&quot;]&#39;.
</span></code></pre>
<p>后续如果是TSX的文件，将不会出现这个问题，也不用显式配置该选项。</p>
<p><code>"jsx"</code></p>
<p>对于<code>"jsx"</code>这个配置，主要有以下几个值：</p>
<ul>
<li><code>react</code>: 将 JSX 改为等价的对 <code>React.createElement</code> 的调用并生成 <code>.js</code> 文件。</li>
<li><code>react-jsx</code>: 改为 <code>__jsx</code> 调用并生成 <code>.js</code> 文件。</li>
<li><code>preserve</code>: 不对 JSX 进行改变并生成 <code>.jsx</code> 文件。</li>
<li><code>react-jsxdev</code>: 改为 <code>__jsx</code> 调用并生成 <code>.js</code> 文件。</li>
<li><code>react-native</code>: 不对 JSX 进行改变并生成 <code>.js</code> 文件。</li>
</ul>
<p>下图展示了当<code>"jsx"</code>的配置分别为：<code>"react"</code>、<code>"react-jsx"</code>的结果：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/080-tsconfig-jsx-result.png" alt="080-tsconfig-jsx-result" /></p>
<p>不难发现，<code>"react"</code>与<code>"react-jsx"</code>配置的编译结果，与前面babel编译中插件<code>@babel/plugin-transform-react-jsx</code>的<code>"runtime"</code>的配置分别为<code>"classic"</code>（或默认不配置）、<code>"automatic"</code>的编译结果能够相对应。</p>
<blockquote>
<p>tsconfig默认使用commonjs作为模块化方案，所以，<code>"jsx": "react-jsx"</code>配置的编译结果中引用<code>react/jsx-runtime</code>时，使用commonjs规范的<code>require</code>。如果给tsconfig.json添加配置<code>"module": "ES6"</code>，则会看到<code>import {jsx as __jsx} from 'react/jsx-runtime'</code>的引用方式。</p>
</blockquote>
<h1 id="zheng-wen-jsx-tsx-de-lei-xing-jian-cha">正文：JSX（TSX）的类型检查</h1>
<p>在《2023-04-08-TypeScript必知三部曲（一）TypeScript编译方案以及IDE对TS的类型检查》中，我们已经了解了，babel不会参与TS代码的类型检查，TS代码本身的类型检查、IDE上的类型检查提示，都是经过tsc配合tsconfig配置完成。所以，接下来我们所谈的关于JSX（TSX）的类型检查，将会围绕tsc+tsconfig来进行讨论。</p>
<h2 id="zhun-bei-gong-zuo">准备工作</h2>
<p>在进行讨论之前，我们依然准备一个样例，这个样例与前面关于tsc编译体系的样例差别不大，<strong>重点在于index.jsx改为了index.tsx</strong>：</p>
<p>（1）源代码src/index.tsx：</p>
<pre data-lang="tsx" style="background-color:#2b303b;color:#c0c5ce;" class="language-tsx "><code class="language-tsx" data-lang="tsx"><span style="color:#b48ead;">const </span><span style="color:#8fa1b3;">MyButton </span><span>= (</span><span style="color:#bf616a;">props</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>&lt;</span><span style="color:#bf616a;">button</span><span>&gt;</span><span style="color:#ab7967;">{</span><span style="color:#bf616a;">props</span><span>.</span><span style="color:#bf616a;">children</span><span style="color:#ab7967;">}</span><span>&lt;/</span><span style="color:#bf616a;">button</span><span>&gt;
</span><span>
</span><span style="color:#b48ead;">export function </span><span style="color:#8fa1b3;">App</span><span>() {
</span><span>    </span><span style="color:#b48ead;">return </span><span>&lt;</span><span style="color:#bf616a;">h1</span><span>&gt;&lt;</span><span style="color:#ebcb8b;">MyButton</span><span>&gt;Hello World&lt;/</span><span style="color:#ebcb8b;">MyButton</span><span>&gt;&lt;/</span><span style="color:#bf616a;">h1</span><span>&gt;;
</span><span>}
</span></code></pre>
<p>（2）tsconfig.json：</p>
<pre data-lang="json" style="background-color:#2b303b;color:#c0c5ce;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">compilerOptions</span><span>&quot;: {
</span><span>    &quot;</span><span style="color:#a3be8c;">module</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">ES6</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">jsx</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">react</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">outDir</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">dist</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">rootDir</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">src</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">allowJs</span><span>&quot;: </span><span style="color:#d08770;">true
</span><span>  }
</span><span>}
</span></code></pre>
<p><strong>注意<code>"jsx"</code>的配置我们使用<code>"react"</code>。</strong></p>
<p>（3）安装typescript并添加编译脚本：</p>
<pre data-lang="json" style="background-color:#2b303b;color:#c0c5ce;" class="language-json "><code class="language-json" data-lang="json"><span>{
</span><span>  &quot;</span><span style="color:#a3be8c;">name</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">jsx-tsc-example</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">version</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1.0.0</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">main</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">index.js</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">license</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">MIT</span><span>&quot;,
</span><span>  &quot;</span><span style="color:#a3be8c;">scripts</span><span>&quot;: {
</span><span>    &quot;</span><span style="color:#a3be8c;">build</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">tsc -p tsconfig.json</span><span>&quot;
</span><span>  },
</span><span>  &quot;</span><span style="color:#a3be8c;">devDependencies</span><span>&quot;: {
</span><span>    &quot;</span><span style="color:#a3be8c;">typescript</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">^5.0.4</span><span>&quot;
</span><span>  }
</span><span>}
</span></code></pre>
<p>准备后整体如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/090-tsx-tsc-example-project.png" alt="090-tsx-tsc-example-project" /></p>
<h2 id="lei-xing-wen-ti">类型问题</h2>
<p>在上述的项目搭建完成后，我们会发现一个问题：在index.tsx代码中，我们用到了两个jsx基础标签：<code>&lt;button&gt;</code>、<code>&lt;h1&gt;</code>以及我们自己编写的React组件<code>&lt;MyButton&gt;</code>，但IDE替我们显示了红色，鼠标悬浮以后，会看到报错提示：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/100-tsx-jsxreact-error-result.png" alt="100-tsx-jsxreact-error-result" /></p>
<ul>
<li><strong>Cannot find name 'React'.</strong></li>
</ul>
<p>为什么会这样呢？针对该问题，需要两个知识点来解释。</p>
<p>第一，tsconfig.json的<code>"jsx": "react"</code>配置的编译结果是将 JSX 改为等价的对 <code>React.createElement</code> 的调用并生成 <code>.js</code> 文件；</p>
<p>第二，IDE进行TS的类型检查流程如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/110-IDE-ts-check-flow.png" alt="110-IDE-ts-check-flow" /></p>
<p>基于上述两点，我们可以解释这个出错的过程为：IDE识别到了tsconfig.json中的<code>"jsx": "react"</code>配置，调用了形如<code>tsc --noEmit</code>的指令，又因为我们的项目没有添加对<code>react</code>的依赖（类型文件也没有），因此出现了这个地方的IDE报错提示。不难想到，我们实际运行脚本进行编译的时候，会出现同样的错误：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/120-tsx-jsxreact-error-result-in-cli.png" alt="120-tsx-jsxreact-error-result-in-cli" /></p>
<blockquote>
<p>细心的小伙伴会看到dist目录下依然生成了index.js代码，因为类型检查结果实际上不妨碍实际js代码的生成。</p>
</blockquote>
<p>上面的配置，我们使用了<code>"jsx": "react"</code>，当我们修改为<code>"jsx": "react-jsx"</code>又会有什么效果呢？</p>
<p>修改配置以后，报错如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/130-tsx-jsxreactjsx-error-result.png" alt="130-tsx-jsxreactjsx-error-result" /></p>
<p>有两方面：</p>
<ul>
<li>
<p>Cannot find module 'react/jsx-runtime'。</p>
</li>
<li>
<p>Did you mean to set the 'moduleResolution' option...。</p>
</li>
</ul>
<p>当我们将<code>"moduleResolution": "node"</code>添加以后可以解决问题2，剩下的问题就是：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/140-tsx-jsxreactjsx-error-result-with-moduleResolution-Node.png" alt="140-tsx-jsxreactjsx-error-result-with-moduleResolution-Node" /></p>
<ul>
<li><strong>Cannot find module 'react/jsx-runtime' or its corresponding type declarations.</strong></li>
</ul>
<blockquote>
<p>无法找到模块<code>react/jsx-rutnime</code>或它对应的类型声明。</p>
</blockquote>
<p>对照前面的<code>"jsx": "react"</code>，当我们的配置改为了<code>"jsx": "react-jsx"</code>以后，JSX标签都将编译为<code>_jsx("div", ..., ...)</code>的调用形式，而这个<code>_jsx</code>来源于：<code>import {jsx as _jsx} from 'react/jsx--runtime'</code>，而我们的项目并没有安装这个包。所以，IDE根据<code>react-jsx"</code>配置的结果，识别到了问题，并帮助我们提示了对应的问题。</p>
<p>无论是<code>Cannot find name 'React'.</code>还是<code>Cannot find module 'react/jsx-runtime' or its corresponding type declarations.</code>问题，要处理起来也很简单，安装react以及其类型定义：</p>
<pre data-lang="shell" style="background-color:#2b303b;color:#c0c5ce;" class="language-shell "><code class="language-shell" data-lang="shell"><span>yarn add react
</span><span>yarn add -D @types/react
</span></code></pre>
<p><code>@types/react</code>中包含了<code>React</code>和<code>react/jsx-runtime</code>类型定义。</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/150-tsx-jsxreactjsx-error-result-import-react.png" alt="150-tsx-jsxreactjsx-error-result-import-react" /></p>
<p>终于，我们不再有类型问题了。此时，我们看看这些h1、button标签到底是什么类型以及ts是如何对这些JSX标签进行类型定义的。</p>
<p>在安装了<code>@types/react</code>后，IDEA里面，通过CTRL+鼠标左键点击相关的标签就能进入到对应的定义里面，比如我们查看<code>&lt;a&gt;</code>标签的具体定义：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/160-jsx-tag-dts.png" alt="160-jsx-tag-dts" /></p>
<p>通过查看类型定义dts文件，可以很容易的看到该类型为：<code>JSX.IntrinsicElements.a</code>。这个<code>JSX.IntrinsicElements</code>接口是什么呢？让我们探索。</p>
<h2 id="lei-xing-jian-cha-de-yuan-tou-jsx-intrinsicelements">类型检查的源头：JSX.IntrinsicElements</h2>
<blockquote>
<p>Intrinsic：固有的，本质的，根本的。</p>
</blockquote>
<p>内在元素（IntrinsicElements）在特殊接口（既<code>JSX.IntrinsicElements</code>接口）上查找。 默认情况下，如果未指定此接口，则在TypeScript进行类型检查的时候，会直接忽略这些类型JSX标签具体的类型定义，任何JSX都不会对内部元素进行类型检查。 但是，如果存在此接口定义，则内部元素的名称将作为接口上的属性进行查找。</p>
<p>举一个简单的例子，我们可以尝试修改上图中react的dts代码，添加一个新的接口字段abc，该字段还有一个必填的<code>name</code>属性：</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>        interface IntrinsicElements {
</span><span style="color:#a3be8c;">+           abc: { name: string; children?: Element };
</span><span>        }
</span></code></pre>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/170-jsx-tag-dts-add-abc-example.png" alt="170-jsx-tag-dts-add-abc-example" /></p>
<p>于是，在代码中，我们就能使用这个<code>&lt;abc&gt;</code>标签，同时，如果不填写<code>name</code>字段的值，TS还会有类型检查异常，只有正确填写<code>name</code>属性才能通过类型检查：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/180-jsx-use-abc-tag.png" alt="180-jsx-use-abc-tag" /></p>
<p>同时，当我们检查编译后的代码，会发现无论是<code>"jsx": "react"</code>还是<code>"jsx": "react-jsx"</code>，关于我们使用的<code>&lt;abc&gt;</code>标签的部分，都变成了字符串<code>"abc"</code>的处理（这里只用tsc编译演示，babel是同样的结果，不再赘述）：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/190-jsx-use-abc-tag-compile-result.png" alt="190-jsx-use-abc-tag-compile-result" /></p>
<p>当然，我们还能编写自己的自定义组件，譬如上面示例里面的<code>&lt;MyButton&gt;</code>。<code>MyButton</code>是一个函数组件，满足React DTS文件里面的类型定义关于使用函数组件类型进行createElement的类型定义：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/200-func-comp-dts.png" alt="200-func-comp-dts" /></p>
<p>总结来讲，JSX（TSX）中关于<strong>内置标签</strong>的类型检查流程如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/210-intrinsic-elements-type-check-flow.png" alt="210-intrinsic-elements-type-check-flow" /></p>
<p>在前面，我们在react的官方dts中的<code>JSX.IntrinsicElements</code>添加了<code>abc</code>字段，所以我们才能编写<code>&lt;abc&gt;</code>标签并通过类型检查。但这种方式目前来讲，有个问题：非常不优雅，居然去修改react类型定义代码。那么，还有什么方式扩展JSX的内置标签元素呢？编写声明文件扩充即可：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-04-18/220-extend-intrinsic-elements.png" alt="220-extend-intrinsic-elements" /></p>
<p>上图中，我们主动声明了<code>JSX.IntrinsicElements</code>接口，并且向里面添加了<code>a-custom-tag</code>，于是，后面的tsx代码中我们就能使用<code>&lt;a-custom-tag&gt;</code>这个标签了。</p>
<p>但要注意的是，我们声明的种种类型，<strong>只针对类型检查</strong>。它仅仅保证了tsc在进行类型检查的正确性。而实际编译后的代码，因为会生成诸如：<code>React.createElement("a-custom-tag", ...)</code>或<code>_jsx('a-cutoms-tag', ...)</code>等调用的js代码。不难想到在实际运行过程中，React内部是无法处理这个所谓的<code>a-custom-tag</code>的“内置标签”的，它就不明白这个<code>"a-custom-tag"</code>是什么，所以在运行时一定会有错误。</p>
<p>在前言中，我们已经解释了如何将JSX编译为react、react/runtime的相关调用。那么，我们可以自定义处理JSX代码吗？当然可以，如果使用的是babel编译体系，则需要自己编写babel插件；如果是tsc编译体系，则需要自定义<code>jsxFactory</code>，像是solidjs，就有自己的babel插件（<a rel="noopener" target="_blank" href="https://www.npmjs.com/package/babel-preset-solid">babel-preset-solid - npm (npmjs.com)</a>）。本文不再赘述关于自定义JSX的编译过程了，网上有很多优秀的文章可以阅读。</p>
<h1 id="xie-zai-zui-hou">写在最后</h1>
<p>本文的内容其实还是有点杂乱，后续可能会重构这篇文章。</p>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>