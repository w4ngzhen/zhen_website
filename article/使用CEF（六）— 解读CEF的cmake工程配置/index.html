<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        使用CEF（六）— 解读CEF的cmake工程配置
    </h1>
</div>

    </header>
    <p class="article-date">2023-10-11</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#cmakeji-chu-dao-ru">CMake基础导入</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#target">target</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#ding-ceng-cmakelists-txt">顶层CMakeLists.txt</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#overview">OVERVIEW</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#cmake-structure">CMAKE STRUCTURE</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#build-requirements">BUILD REQUIREMENTS</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#build-examples">BUILD EXAMPLES</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#libcef-dll-cmakelists-txt">libcef_dll&#x2F;CMakeLists.txt</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#cefsimple-cmakelists-txt">cefsimple&#x2F;CMakeLists.txt</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/使用CEF（六）— 解读CEF的cmake工程配置/#xie-zai-zui-hou">写在最后</a>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <p>距离笔者的《使用CEF》系列的第一篇文章居然已经过去两年了，在这么长一段时间里，笔者也写了很多其它的文章，再回看《使用CEF（一）— 起步》编写的内容，文笔稚嫩，内容单薄是显而易见的（主要是教大家按部就班的编译libcef_dll_wrapper库文件）。笔者一直以来的个性就是希望自己学习到的知识，研究出的内容，踩过的坑能够及时的写出来，介绍给更多的小伙伴。</p>
<p>这篇文章产生的背景是最近笔者再一次仔细的阅读了CEF binary distribution（CEF二进制分发包）的工程代码以及根目录下的CMakeLists.txt文件的所了解到的东西，希望在本文能够让读者小伙伴对于CEF binary distribution的工程结构有一个较为清晰的了解。</p>
<span id="continue-reading"></span><h1 id="cmakeji-chu-dao-ru">CMake基础导入</h1>
<p>CMake是什么，它和Unix下的make+gcc、macOS下的xcode+clang以及Windows下的VS+msvc工具链的关系不在本文解释，但阅读本文还是需要对CMake所扮演的角色有基本认识，所以如果你还不是特别清楚，建议先从笔者这一篇文章了解下《<a rel="noopener" target="_blank" href="https://zhuanlan.zhihu.com/p/655701220">C与CPP常见编译工具链与构建系统简介 - 知乎 (zhihu.com)</a>》。CMake本身无法构建任何的应用，它生成不同构建工具所需要的配置或某种输入，再让构建工具基于配置调用工具链，对代码进行构建。</p>
<h2 id="target">target</h2>
<p>一般来说，我们使用CMake来构建某种产物（这里的“构建”不严谨，只是方便描述），这个产物可以是可执行二进制程序直接运行，可以是一个库文件。构建产物在CMake中被抽象成了名为<strong>target</strong>的东西，CMake的核心运转就是围绕target进行的。</p>
<p>在CMake中定义某个target，最最最基础的方式有两种：<code>add_executable</code>和<code>add_library</code>。</p>
<p><strong>add_executable()</strong>：<a rel="noopener" target="_blank" href="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable — CMake 3.27.6 Documentation</a></p>
<p>该命令用于定义一个可以构建成可执行程序的target，简单用法形式如下：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#96b5b4;">add_executable</span><span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]
</span><span>               [EXCLUDE_FROM_ALL]
</span><span>               [source1] [source2 ...])
</span></code></pre>
<ul>
<li>第一个必填参数<code>name</code>，就是我们要编译的可执行程序target的名称；</li>
<li>可选参数<code>WIN32</code>、<code>MACOS_BUNDLE</code>。分别用于Windows平台和macOS平台<strong>可执行应用程序</strong>的构建。如果没有配置这个参数，你会发现最终编译的可执行程序本质上就是从控制台程序启动的程序。两个最直观的例子：在Windows上的QT GUI项目，没有配置<code>WIN32</code>参数，那么编译后运行起来时除了我们的GUI窗体展示，还会有一个黑色控制台窗口展示；在macOS上，你经常看到的某某应用<code>XXX.app</code>实际上是一个bundle，里面有这个应用的各种配置、实际运行的可执行文件等，如果你想要最终构建出来的属于这种应用程序，那么就需要<code>MACOS_BUNDLE</code>参数；</li>
<li>可选参数<code>EXCLUDE_FROM_ALL</code>，表明整个项目构建的时候，排除当前这个target；</li>
<li>至于<code>source1</code>、<code>source2</code>等等就是头文件、源码文件了。</li>
</ul>
<p><strong>add_library()</strong>：<a rel="noopener" target="_blank" href="https://cmake.org/cmake/help/latest/command/add_library.html">add_library — CMake 3.27.6 Documentation</a></p>
<p>该命令用于定义一个生成的库文件的target，<strong>普通用法</strong>形式如下：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#96b5b4;">add_library</span><span>(&lt;name&gt; [STATIC | </span><span style="color:#bf616a;">SHARED </span><span>| </span><span style="color:#bf616a;">MODULE</span><span>]
</span><span>            [EXCLUDE_FROM_ALL]
</span><span>            [&lt;source&gt;...])
</span></code></pre>
<ul>
<li>第一个必填参数<code>name</code>，就是我们要编译的库文件target的名称；</li>
<li>参数<code>STATIC</code>、<code>SHARED</code>、<code>MODULE</code>互斥三选一。<code>STATIC</code>表明希望将这个库文件编译为静态库；<code>SHARED</code>表明希望将这个库文件编译为动态连接库；<code>MODULE</code>表明编译为一个动态库，但是通过运行时以程序的方式加载（比如dlopen在Unix-like系统中，或LoadLibrary在Windows系统中）。</li>
<li>可选参数<code>EXCLUDE_FROM_ALL</code>，表明整个项目构建的时候，排除当前这个target；</li>
<li>至于<code>source</code>等等就是头文件、源码文件了。</li>
</ul>
<p><strong>target_include_directories与target_link_libraries</strong></p>
<p>想要构建C/C++工程，我们经常需要在编译阶段使用<strong>外部库</strong>的头文件分析依赖与内存布局，以及在链接阶段链接这些外部库文件。在CMake中，我们一般使用<code>target_include_directories</code>指令来指定对应target编译过程中外部库头文件的搜索路径，以及使用<code>target_link_libraries</code>指令来指定链接阶段要链接哪些库文件，具体用法读者自行了解。</p>
<p>值得注意的是，除了上述两个指令外，你还会搜索到两个类似的指令<code>include_directories</code>和<code>link_libraries</code>。这两个指令命名上没有<code>"target_"</code>前缀，其作用主要是提供全局的头文件和链接库搜索路径。这个两个全局作用的指令的背景在于CMake是支持多target模块构建的，可以通过项目顶层的CMakeLists.txt中配置这两个指令，让子模块target共享这些头文件和库文件路径配置。但是如没有必要，尽可能使用<code>target_xxx</code>来给指定的target配置。举一反三，CMake中还有很多的<code>target_</code>开头的指令，其目的都是针对某个指定的target的配置。</p>
<p>由于篇幅原因，本文关于CMake基本导入的部分就介绍到这里，接下来，让我们逐步分析CEF binary distribution中的CMakeLists.txt。</p>
<h1 id="ding-ceng-cmakelists-txt">顶层CMakeLists.txt</h1>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/010-root-CMakeLists.png" alt="010-root-CMakeLists" /></p>
<h2 id="overview">OVERVIEW</h2>
<p>overview部分简单介绍了CMake，然后介绍CEF binary distribution不同平台下支持的项目构建系统和工具链：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># Linux:      Ninja, GCC 7.5.0+, Unix Makefiles
</span><span style="color:#65737e;"># MacOS:      Ninja, Xcode 12.2 to 13.0
</span><span style="color:#65737e;"># Windows:    Ninja, Visual Studio 2022
</span></code></pre>
<h2 id="cmake-structure">CMAKE STRUCTURE</h2>
<p>该部分介绍了CEF binary distribution的CMAKE工程结构，说明了CEF二进制分发包主要由以下几个部分组成：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># CMakeLists.txt              Bootstrap that sets up the CMake environment.
</span><span style="color:#65737e;"># cmake/*.cmake               CEF configuration files shared by all targets.
</span><span style="color:#65737e;"># libcef_dll/CMakeLists.txt   Defines the libcef_dll_wrapper target.
</span><span style="color:#65737e;"># tests/*/CMakeLists.txt      Defines the test application target.
</span></code></pre>
<ul>
<li>CMakeLists.txt：组织构建CEF二进制分发的CMake环境。</li>
<li>cmake/*.cmake：CMake配置文件，可被所有的target使用。</li>
<li>libcef_dll/CMakeLists.txt：定义了<code>libcef_dll_wrapper</code>这个target的CMake配置。</li>
<li>tests/*/CMakeLists.txt：定义了所有的测试Demo应用target。</li>
</ul>
<h2 id="build-requirements">BUILD REQUIREMENTS</h2>
<p>该部分主要介绍了编译<code>libcef_dll_wrapper</code>以及相关样例demo在不同操作系统平台上的环境要求。</p>
<h2 id="build-examples">BUILD EXAMPLES</h2>
<p>这一部分主要介绍了如何构建<code>libcef_dll_wrapper</code>以及demo。具体的做法就是在<code>cef_binary_xxx目录</code>（后续都用该指代CEF binary distribution文件夹根目录）中创建一个名为<code>build</code>的目录，进入该目录后，针对不同的平台，使用CMake生成不同的构建系统的工程配置，并进行构建。其中，由于Ninja是一个跨平台的<strong>构建系统</strong>，所以你会看每个平台都有Ninja构建系统的生成指令。例如，下图展示了在macOS x86 64位架构上使用CMake生成对应的构建方案的两种方式：1、xcode构建方案（xcodebuild构建方案体系）；2、Ninja构建方案。</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/020-macOS-cmake-build.png" alt="020-macOS-cmake-build" /></p>
<blockquote>
<p>无论是xcode还是ninja，都是构建系统，在macOS上最终调用编译工具链是底层的clang/LLVM。</p>
</blockquote>
<p>再比如，在Windows64位系统上也有两种方式：1、VisualStudio解决方案（MSBuild构建方案体系）；2、Ninja构建方案。</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/030-Windows-cmake-build.png" alt="030-Windows-cmake-build" /></p>
<blockquote>
<p>同样的，无论是vs MSBuild还是ninja，都是构建系统，在Windows上最终调用的是底层的msvc编译工具链。</p>
</blockquote>
<p>对于使用Ninja，读者会看到都会调用<code>ninja cefclient cefsimple</code>，这个命令运行后，会编译demo中的cefclient和cefsimple两个项目，这里只是官方例子，在实际使用过程中，并不是一定要按照它的操作来。另外，有读者可能有疑问，这个过程并没有看到关于<code>libcef_dll_wrapper</code>项目的构建，这里先提前说明一下，在cefsimple和cefclient等demo中依赖了<code>libcef_dll_wrapper</code>并通过配置进行了指定，所以构建的过程中，会优先自动编译<code>libcef_dll_wrapper</code>。关于这块，等我们后面详解的时候会介绍的。</p>
<p>在看完了关于不同平台的构建方式以后，我们往下会看到关于<code>"Global setup."</code>的部分。这一部分开始，就是CMake真正有关的部分了。让我们首先删除掉所有的注释，逐步分析这个顶层CMakeLists.txt的配置：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/040-root-CMakeLists.png" alt="040-root-CMakeLists" /></p>
<p>剔除了注释以后，会发现其实内容并不多。这里我们首先从上图第8行开始关于设置<code>CEF_ROOT</code>和<code>CMAKE_MODULE_PATH</code>的分析：配置首先定义了<code>CEF_ROOT</code>，它使用了CMake提供的变量<code>CMAKE_CURRENT_SOURCE_DIR</code>，也就是当前CMakeLists.txt所在目录：<code>cef_binary_xxx</code>目录；然后对<code>CMAKE_MODULE_PATH</code><strong>追加</strong>了<code>${CEF_ROOT}/cmake</code>这个目录。</p>
<p>之所以这样做，是因为接下来<code>find_package(CEF REQUIRED)</code>会根据<code>CMAKE_MODULE_PATH</code>所提供的路径进行搜索。关于<code>find_package</code>，网上解析的文章很多，这里只简单说明下，CMake官方文档中提到<code>find_package</code>有两种搜索模式，其中一种就是<strong>模块搜索模式</strong>（Module mode），该搜索模式说明如下：</p>
<blockquote>
<p>Module mode
In this mode, CMake searches for a file called <code>Find&lt;PackageName&gt;.cmake</code>, looking first in the locations listed in the <code>CMAKE_MODULE_PATH</code>, then among the Find Modules provided by the CMake installation. If the file is found, it is read and processed by CMake.</p>
</blockquote>
<p>翻译过来就是：当运行<code>find_package(PackageName)</code>的时候，CMake会在<code>CMAKE_MODULE_PATH</code>路径列表中，查找名为<code>Find&lt;PakcageName&gt;.cmake</code>文件，找到后就会对该配置文件加载并处理。对照本例，<code>find_package(CEF REQUIRED)</code>，在模块搜索模式下，则是需要查找一个名为<code>FindCEF.cmake</code>的文件。由于我们在<code>CMAKE_MODULE_PATH</code>中追加了<code>${CEF_ROOT}/cmake</code>这个目录，即<code>cef_binary_xxx/cmake</code>目录，所以CMake会搜索这个目录，该目录确实存在<code>FindCEF.cmake</code>文件，于是被CMake命中并加载了。那么，接下来让我们打开该<code>FindCEF.cmake</code>文件，一探究竟。</p>
<h3 id="findcef-cmake">FindCEF.cmake</h3>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/050-FindCEF.png" alt="050-FindCEF" /></p>
<p><code>FindCEF.cmake</code>很好理解，大致处理过程是：</p>
<p>首先从CMake全局上下文或系统环境变量等地方读取名为<code>CEF_ROOT</code>的值，这个值是一个目录，指代了<code>cef_binary_xxx</code>目录，然后校验该目录路径是否合法（路径下的cmake目录是否存在），并赋值给<code>_CEF_ROOT</code>（<strong>这个值很关键，接下来都是使用这个_CEF_ROOT值</strong>）；</p>
<p>然后，给<code>CMAKE_MODULE_PATH</code>追加<code>${_CEF_ROOT}/cmake</code>路径，与之前<code>cef_binary_xxx/CMakeList.txt</code>中追加该PATH目的不一样，这一次追加<code>CMAKE_MODULE_PATH</code>值的核心目的是为下面调用<code>include("cef_variables")</code>和<code>include("cef_macros")</code>的时候，能够找到<code>${_CEF_ROOT}/cmake</code>路径下名为<code>cef_variables.cmake</code>和<code>cef_macros.cmake</code>文件。</p>
<blockquote>
<p>CMake的官方文档告诉我们，CMake在处理<code>include("abc")</code>的时候，会搜索<code>CMAKE_MODULE_PATH</code>路径下名为<code>abc.cmake</code>的文件进行加载处理。<a rel="noopener" target="_blank" href="https://cmake.org/cmake/help/latest/command/include.html#include">CMake - include</a></p>
</blockquote>
<p>看到这里，有的读者可能已经绕晕了，我们做一个简单的流程图来描述这个过程：</p>
<p>cef-binary-xxx/CMakeList.txt -&gt; find_package(CEF REQUIRED) -&gt; 在第一次 CMAKE_MODULE_PATH路径配置前提下，找到了 FindCEF.cmake配置读取；FindCEF.cmake -&gt; include("cef_variables")、include("cef_macros")，按顺序加载 cef_variables.cmake 和 cef_macros.cmake。</p>
<p>我们暂时不深入研究<code>cef_variables.cmake</code>、<code>cef_macros.cmake</code>里的内容，后面遇到一些特殊的变量、宏的时候，我们再来解释，这里我们可以先跳出细节，可以认为<code>cef_variables</code>和<code>cef_macros</code>里面分别定义了一些变量配置和宏定义，供后续CMake处理流程读取或调用。</p>
<h1 id="libcef-dll-cmakelists-txt">libcef_dll/CMakeLists.txt</h1>
<p>现在，让我们回到<code>cef_binary_xxx/CMakeLists.txt</code>，在<code>find_package(CEF)</code>之后，紧接着的就是<code>add_subdirectory()</code>指令：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># Include the libcef_dll_wrapper target.
</span><span style="color:#65737e;"># Comes from the libcef_dll/CMakeLists.txt file in the binary distribution
</span><span style="color:#65737e;"># directory.
</span><span style="color:#96b5b4;">add_subdirectory</span><span>(${</span><span style="color:#bf616a;">CEF_LIBCEF_DLL_WRAPPER_PATH</span><span>} libcef_dll_wrapper)
</span></code></pre>
<p>这里出现了一个变量：<code>CEF_LIBCEF_DLL_WRAPPER_PATH</code>，它来源于<code>cef_variables.cmake</code>中定义的：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/060-CEF_LIBCEF_DLL_WRAPPER_PATH.png" alt="060-CEF_LIBCEF_DLL_WRAPPER_PATH" /></p>
<p>也就是说，在本例中，<code>add_subdirectory(${CEF_LIBCEF_DLL_WRAPPER_PATH} libcef_dll_wrapper)</code>就是添加了子目录<code>cef_binary_xxx/libcef_dll</code>。一旦添加了该子模块目录，CMake就会在该目录下搜索对应的CMakeLists.txt文件并进行加载（这里就是<code>cef_binary_xxx/libcef_dll/CMakeLists.txt</code>）。</p>
<p>这份<code>libcef_dll/CMakeLists.txt</code>主要就是将<code>libcef_dll_wrapper</code>的各种源码、以及<code>libcef</code>的头文件、各种平台特定的源代码文件放到一些CMake变量中，最后的通过<code>add_library</code>指令，定义了一个名为<code>libcef_dll_wrapper</code>的target，并将前面的源代码、头文件等添加到这个target中：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/070-add-source-to-target.png" alt="070-add-source-to-target" /></p>
<p>写到这里，我们可以对<code>cef_binary_xxx/CMakeLists.txt</code>文件做一个简单的概念总结。首先，该CMakeLists.txt扮演的是项目顶层统领全局的角色，它并没有定义过任何的target，而是通过两个步骤组织了`CEF binary distribution目录中的libcef_dll_wrapper、demo等target的构建：</p>
<p>步骤一：负责预构造CMake处理环境上下文，包括准备各种配置变量、宏方法等，供后续过程使用。这个过程具体是是通过加载<code>FindCEF.cmake</code>，并在该文件内部再加载<code>cef_variables.cmake</code>和<code>cef_macros.cmake</code>两个配置。</p>
<p>步骤二：通过<code>add_subdirectory</code>添加并管理起子模块target，包括<code>libcef_dll_wrapper</code>以及各种demo的target。这个过程CMake会读取对应路径下的<code>CMakeLists.txt</code>并加载。同时，这些文件中使用到的一些CEF提供的变量、宏都来自于步骤一所加载的<code>cef_variables.cmake</code>和<code>cef_macros.cmake</code>。</p>
<h1 id="cefsimple-cmakelists-txt">cefsimple/CMakeLists.txt</h1>
<p>因为<code>libcef_dll_wrapper</code>这个target最终产物是一个库文件，所以这个target所在CMakeLists.txt内容虽然很多，但是比较直白，就是各种源代码、头文件的添加。但是，如果target产物是一个可执行程序，CMakeLists.txt还会这么简单吗？这里我们分析下cefsimple这个样例的CMakeLists.txt。</p>
<p>首先，cefsimple存放于<code>cef_binary_xxx/tests/cefsimple</code>目录中，在<code>cef_binary_xxx/CMakeLists.txt</code>中，同样通过<code>add_subdirectory</code>添加：</p>
<pre data-lang="CMake" style="background-color:#2b303b;color:#c0c5ce;" class="language-CMake "><code class="language-CMake" data-lang="CMake"><span style="color:#bf616a;">f</span><span>(</span><span style="color:#bf616a;">EXISTS </span><span>&quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CMAKE_CURRENT_SOURCE_DIR</span><span style="color:#a3be8c;">}/tests</span><span>&quot;)
</span><span>  </span><span style="color:#96b5b4;">add_subdirectory</span><span>(tests/cefsimple) </span><span style="color:#65737e;"># cefsimple
</span><span>  </span><span style="color:#96b5b4;">add_subdirectory</span><span>(tests/gtest)
</span><span>  </span><span style="color:#96b5b4;">add_subdirectory</span><span>(tests/ceftests)
</span><span style="background-color:#bf616a;color:#2b303b;">endif</span><span>()
</span></code></pre>
<blockquote>
<p>这里之所以使用一个目录判断，目测是在CEF binary distribution的Minimal最小版本中，是剔除了样例工程的，所以做了一个IF判断。</p>
</blockquote>
<p>所以，接下来我们开始分析<code>cef_binary_xxx/tests/cefsimple/CMakeLists.txt</code>文件。</p>
<p>源文件定义</p>
<p>该文件实际上也分为两个部分。第一部分就是通过变量来存储cefsimple的相关源码、头文件：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/080-add-source-for-simple-demo.png" alt="080-add-source-for-simple-demo" /></p>
<p>这一块我们挑一个比较典型的处理：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/090-handle-flow.png" alt="090-handle-flow" /></p>
<p>首先使用<code>CEFSIMPLE_SRCS</code>来存储平台无关的源代码和头文件。其次，由于不同操作系统平台下有一些平台特定的源代码，例如macOS下，设置窗体标题，我们可以使用objective-c代码（<code>.m</code>/<code>.mm</code>文件）来使用原生API操作窗体标题，所以使用<code>CEFSIMPLE_SRCS_平台标识</code>变量存储这些平台特定代码的列表；最后，使用一个名为<code>APPEND_PLATFORM_SOURCES</code>的宏来处理<code>CEFSIMPLE_SRCS</code>变量，这里有两个疑问点：1、这个宏的来源和作用；2、<code>CEFSIMPLE_SRCS_平台标识</code>变量似乎没有用到。这两个疑问点一起解释。实际上，这个宏就是来源于<code>cef_macros.cmake</code>中，找到对应宏的源码：</p>
<pre data-lang="CMake" style="background-color:#2b303b;color:#c0c5ce;" class="language-CMake "><code class="language-CMake" data-lang="CMake"><span style="color:#65737e;"># Append platform specific sources to a list of sources.
</span><span style="color:#96b5b4;">macro</span><span>(</span><span style="color:#8fa1b3;">APPEND_PLATFORM_SOURCES </span><span>name_of_list)
</span><span>  </span><span style="color:#b48ead;">if</span><span>(OS_LINUX AND ${</span><span style="color:#bf616a;">name_of_list</span><span>}_LINUX)
</span><span>    </span><span style="color:#96b5b4;">list</span><span>(</span><span style="color:#bf616a;">APPEND </span><span>${</span><span style="color:#bf616a;">name_of_list</span><span>} ${${</span><span style="color:#bf616a;">name_of_list</span><span>}</span><span style="color:#bf616a;">_LINUX</span><span>})
</span><span>  </span><span style="color:#b48ead;">endif</span><span>()
</span><span>  </span><span style="color:#b48ead;">if</span><span>(OS_POSIX AND ${</span><span style="color:#bf616a;">name_of_list</span><span>}_POSIX)
</span><span>    </span><span style="color:#96b5b4;">list</span><span>(</span><span style="color:#bf616a;">APPEND </span><span>${</span><span style="color:#bf616a;">name_of_list</span><span>} ${${</span><span style="color:#bf616a;">name_of_list</span><span>}</span><span style="color:#bf616a;">_POSIX</span><span>})
</span><span>  </span><span style="color:#b48ead;">endif</span><span>()
</span><span>  </span><span style="color:#b48ead;">if</span><span>(OS_WINDOWS AND ${</span><span style="color:#bf616a;">name_of_list</span><span>}_WINDOWS)
</span><span>    </span><span style="color:#96b5b4;">list</span><span>(</span><span style="color:#bf616a;">APPEND </span><span>${</span><span style="color:#bf616a;">name_of_list</span><span>} ${${</span><span style="color:#bf616a;">name_of_list</span><span>}</span><span style="color:#bf616a;">_WINDOWS</span><span>})
</span><span>  </span><span style="color:#b48ead;">endif</span><span>()
</span><span>  </span><span style="color:#b48ead;">if</span><span>(OS_MAC AND ${</span><span style="color:#bf616a;">name_of_list</span><span>}_MAC)
</span><span>    </span><span style="color:#96b5b4;">list</span><span>(</span><span style="color:#bf616a;">APPEND </span><span>${</span><span style="color:#bf616a;">name_of_list</span><span>} ${${</span><span style="color:#bf616a;">name_of_list</span><span>}</span><span style="color:#bf616a;">_MAC</span><span>})
</span><span>  </span><span style="color:#b48ead;">endif</span><span>()
</span><span style="color:#96b5b4;">endmacro</span><span>()
</span></code></pre>
<p>这段宏的逻辑实际上就是通过判断操作系统平台，使用CMake提供的list APPEND机制，将入参<code>name_of_list</code>和<code>name_of_list_平台标识</code>合成为一个list列表。比较trick的就是，在调用<code>APPEND_PLATFORM_SOURCES(CEFSIMPLE_SRCS)</code>，内部比如<code>${${name_of_list}_MAC}</code> 就是<code>${CEFSIMPLE_SRCS_MAC}</code>，即获取这个变量的数据。后面剩下关于配置源文件的方式类似，这里就请读者自行分析了。</p>
<p>现在，让我们回到对cefsimple/CMakeLists.txt本身的分析，接下来我们分析比较重要的第二部分：可执行程序的生成：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/100-os-target.png" alt="100-os-target" /></p>
<p>这里我们对macOS平台的可执行程序生成进行讲解，因为它相对于在Windows和Linux更加复杂。首先，定义了在macOS平台下会添加一些编译指令（譬如支持objective-c语言编译）：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#96b5b4;">option</span><span>(OPTION_USE_ARC &quot;</span><span style="color:#a3be8c;">Build with ARC (automatic Reference Counting) on macOS.</span><span>&quot; ON)
</span><span style="color:#b48ead;">if</span><span>(OPTION_USE_ARC)
</span><span>  </span><span style="color:#96b5b4;">list</span><span>(</span><span style="color:#bf616a;">APPEND </span><span>CEF_COMPILER_FLAGS
</span><span>    -fobjc-arc
</span><span>    )
</span><span>  </span><span style="color:#96b5b4;">set_target_properties</span><span>(${</span><span style="color:#bf616a;">target</span><span>} </span><span style="color:#bf616a;">PROPERTIES
</span><span>    CLANG_ENABLE_OBJC_ARC &quot;</span><span style="color:#a3be8c;">YES</span><span>&quot;
</span><span>    )
</span><span style="color:#b48ead;">endif</span><span>()
</span></code></pre>
<p>然后，设置了输出的可执行程序一些名称变量，这里就是<code>"cefsimple.app"</code>：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># Output path for the main app bundle.
</span><span style="color:#96b5b4;">set</span><span>(</span><span style="color:#bf616a;">CEF_APP </span><span>&quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_TARGET_OUT_DIR</span><span style="color:#a3be8c;">}/</span><span>$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_TARGET</span><span style="color:#a3be8c;">}.app</span><span>&quot;)
</span><span>
</span><span style="color:#65737e;"># Variables referenced from the main Info.plist file.
</span><span style="color:#96b5b4;">set</span><span>(</span><span style="color:#bf616a;">EXECUTABLE_NAME </span><span>&quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_TARGET</span><span style="color:#a3be8c;">}</span><span>&quot;)
</span><span style="color:#96b5b4;">set</span><span>(</span><span style="color:#bf616a;">PRODUCT_NAME </span><span>&quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_TARGET</span><span style="color:#a3be8c;">}</span><span>&quot;)
</span></code></pre>
<blockquote>
<p>再次需要提到的是，在macOS，一般可执行程序都会生成为一个App Bundle（<a rel="noopener" target="_blank" href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/AboutBundles/AboutBundles.html">About Bundles (apple.com)</a>）。</p>
</blockquote>
<p>如果启用了<code>USE_SANDBOX</code>标识，则会使用自定义宏（也是在之前的cef_macro.cmake中定义的）<code>ADD_LOGICAL_TARGET</code>进行特殊的处理：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#b48ead;">if</span><span>(USE_SANDBOX)
</span><span>  </span><span style="color:#65737e;"># Logical target used to link the cef_sandbox library.
</span><span>  </span><span style="color:#bf616a;">ADD_LOGICAL_TARGET</span><span>(&quot;</span><span style="color:#a3be8c;">cef_sandbox_lib</span><span>&quot; &quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_SANDBOX_LIB_DEBUG</span><span style="color:#a3be8c;">}</span><span>&quot; &quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_SANDBOX_LIB_RELEASE</span><span style="color:#a3be8c;">}</span><span>&quot;)
</span><span style="color:#b48ead;">endif</span><span>()
</span></code></pre>
<p>接下来就是定义核心应用：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># Main app bundle target.
</span><span style="color:#96b5b4;">add_executable</span><span>(${</span><span style="color:#bf616a;">CEF_TARGET</span><span>} </span><span style="color:#bf616a;">MACOSX_BUNDLE </span><span>${</span><span style="color:#bf616a;">CEFSIMPLE_RESOURCES_SRCS</span><span>} ${</span><span style="color:#bf616a;">CEFSIMPLE_SRCS</span><span>})
</span><span style="color:#bf616a;">SET_EXECUTABLE_TARGET_PROPERTIES</span><span>(${</span><span style="color:#bf616a;">CEF_TARGET</span><span>})
</span><span style="color:#96b5b4;">add_dependencies</span><span>(${</span><span style="color:#bf616a;">CEF_TARGET</span><span>} libcef_dll_wrapper)
</span><span style="color:#96b5b4;">target_link_libraries</span><span>(${</span><span style="color:#bf616a;">CEF_TARGET</span><span>} libcef_dll_wrapper ${</span><span style="color:#bf616a;">CEF_STANDARD_LIBS</span><span>})
</span><span style="color:#96b5b4;">set_target_properties</span><span>(${</span><span style="color:#bf616a;">CEF_TARGET</span><span>} </span><span style="color:#bf616a;">PROPERTIES
</span><span>  MACOSX_BUNDLE_INFO_PLIST ${</span><span style="color:#bf616a;">CMAKE_CURRENT_SOURCE_DIR</span><span>}/mac/Info.plist
</span><span>  )
</span></code></pre>
<p>这段代码执行逻辑解释如下：</p>
<ol>
<li>使用<code>add_executable</code>定义了主程序target，注意添加了参数<code>"MACOSX_BUNDLE"</code>表明最终生成的target是一个macOS下的App Bundle，和在Windows下的<code>"WIN32"</code>参数异曲同工；</li>
<li>使用自定义宏<code>SET_EXECUTALBE_TARGET_PROPERTIES</code>为target添加一些属性；</li>
<li>使用指令<code>add_dependencies</code>定义了我们当前cefsimple依赖了一个<code>libcef_dll_wrapper</code>target，<strong>该指令的核心作用就是能够确定一个target在生成的过程中需要什么依赖。</strong></li>
<li>设置了target一些特殊的properties，这里主要就是定义当生成macOS的App Bundle的时候，会在Bundle中生成Info.plist，这个文件是macOS下App Bundle中一个比较重要文件，用来定义应用的一些与macOS操作系统相关的属性，例如是否支持高分屏检测等。开发过Windows应用的小伙伴都知道，在Windows下，会有一个app.manifest文件，它俩也是异曲同工。</li>
</ol>
<p>接下来就是使用CMake提供的<code>add_custom_command</code>指令，定义了编译生成以后（<code>"POST_BUILD"</code>标识），将相关的文件拷贝至目标目录的流程：</p>
<pre data-lang="cmake" style="background-color:#2b303b;color:#c0c5ce;" class="language-cmake "><code class="language-cmake" data-lang="cmake"><span style="color:#65737e;"># Copy the CEF framework into the Frameworks directory.
</span><span style="color:#96b5b4;">add_custom_command</span><span>(
</span><span>  </span><span style="color:#bf616a;">TARGET </span><span>${</span><span style="color:#bf616a;">CEF_TARGET</span><span>}
</span><span>  </span><span style="color:#bf616a;">POST_BUILD
</span><span>  </span><span style="color:#bf616a;">COMMAND </span><span>${</span><span style="color:#bf616a;">CMAKE_COMMAND</span><span>} -E copy_directory
</span><span>          &quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_BINARY_DIR</span><span style="color:#a3be8c;">}/Chromium Embedded Framework.framework</span><span>&quot;
</span><span>          &quot;$</span><span style="color:#a3be8c;">{</span><span style="color:#bf616a;">CEF_APP</span><span style="color:#a3be8c;">}/Contents/Frameworks/Chromium Embedded Framework.framework</span><span>&quot;
</span><span>  </span><span style="color:#bf616a;">VERBATIM
</span><span>  )
</span></code></pre>
<blockquote>
<p>在使用CMake定义项目结构的时候，我们可以通过<code>add_custom_command</code>来实现编译、构建过程中一些生命周期节点的处理逻辑，譬如拷贝依赖库等。</p>
</blockquote>
<p>接下来的foreach指令，这里定义了n个helper的AppBundle target。譬如渲染进程、GPU加速进程、工具进程等具有特定功能的进程help程序：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/110-helper-target.png" alt="110-helper-target" /></p>
<p>值得注意的是，在macOS下，这里helper的<code>add_executable()</code>添加的是<code>CEFSIMPLE_HELPER_SRCS</code>，这个变量里面存储的是：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/120-helper-source.png" alt="120-helper-source" /></p>
<p>翻看该<code>process_helper_mac.cc</code>源码，其实并不复杂：</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// Entry point function for sub-processes.
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span>(</span><span style="color:#b48ead;">int </span><span style="color:#bf616a;">argc</span><span>, </span><span style="color:#b48ead;">char</span><span>* </span><span style="color:#bf616a;">argv</span><span>[]) {
</span><span style="color:#b48ead;">#if defined</span><span>(CEF_USE_SANDBOX)
</span><span>  </span><span style="color:#65737e;">// Initialize the macOS sandbox for this helper process.
</span><span>  CefScopedSandboxContext sandbox_context;
</span><span>  </span><span style="color:#b48ead;">if </span><span>(!sandbox_context.</span><span style="color:#bf616a;">Initialize</span><span>(argc, argv)) {
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>  }
</span><span style="color:#b48ead;">#endif
</span><span>
</span><span>  </span><span style="color:#65737e;">// Load the CEF framework library at runtime instead of linking directly
</span><span>  </span><span style="color:#65737e;">// as required by the macOS sandbox implementation.
</span><span>  CefScopedLibraryLoader library_loader;
</span><span>  </span><span style="color:#b48ead;">if </span><span>(!library_loader.</span><span style="color:#bf616a;">LoadInHelper</span><span>()) {
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#65737e;">// Provide CEF with command-line arguments.
</span><span>  CefMainArgs </span><span style="color:#bf616a;">main_args</span><span>(argc, argv);
</span><span>
</span><span>  </span><span style="color:#65737e;">// Execute the sub-process.
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">CefExecuteProcess</span><span>(main_args, nullptr, nullptr);
</span><span>}
</span></code></pre>
<p>这里只要熟悉CEF的多进程架构就能理解。不熟悉的伙伴可以阅读这篇文章：<a rel="noopener" target="_blank" href="https://zhuanlan.zhihu.com/p/365414447">使用CEF（三）— 从CEF官方Demo源码入手解析CEF架构与CefApp、CefClient对象 - 知乎 (zhihu.com)</a>。</p>
<p>关于cefsimple/CMakeLists.txt剩下的内容其实也不复杂了，读者可以顺着本文的思路进一步阅读。</p>
<h1 id="xie-zai-zui-hou">写在最后</h1>
<p>通过顶层CMakeLists.txt的说明，不难发现，cef_binary_xxx本身既是包含了了libcef_dll_wrapper源码构建的工程，同时也是一个比较标准的，想要使用libcef+libcef_dll_wrapper的CMake工程，所以，你才会在顶层CMakeLists.txt看到官方介绍了几种基于cef_binary_xxx的CMake工程结构的项目集成案例：</p>
<p><img src="https://static-res.zhen.wang/images/post/2023-10-11/130-how-to-intergate.png" alt="130-how-to-intergate" /></p>
<p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=3d9bi2yhvncwk</p>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>