<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
          name="viewport">
    
    
    <!-- umami web analysis -->
    <script defer src="https://zhen.wang/libs/umami/umami.script.js"
            data-website-id="d66cfe03-f6b3-4aa0-baf8-728700db1b09"></script>
    
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="https://zhen.wang/images/blog-site-icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="https://zhen.wang/images/blog-site-icon.svg">
    <title>zhen&#x27;s everything</title>
    <link rel="stylesheet" href="https://zhen.wang/style.css">
    
<link rel="stylesheet" href="https://zhen.wang/article_content.css">
<link rel="stylesheet" href="https://zhen.wang/article_markdown.css">

</head>
<body>

<div id="article">
    <header class="article-header">
        
<div class="base-title">
    <a href="#" onclick="history.length > 1 ? history.back() : location.href = '/'; return false;">&LeftArrow; Back</a>
    <h1>
        基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操
    </h1>
</div>

    </header>
    <p class="article-date">2024-03-16</p>
    
    <!-- toc -->
    <div class="article-toc">
        <label class="toc-title" for="toc-trigger">目录</label>
        <input id="toc-trigger" type="checkbox" checked/>
        <div class="toc-content">
            <ol class="toc">
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#ji-ben-mo-shi">基本模式</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#jian-dan-hui-zhi-yi-ge-ju-xing">简单绘制一个矩形</a>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#fu-za-tu-xing">复杂图形</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#mesh">Mesh</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#meshbuilderyu-meshdata">MeshBuilder与MeshData</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#instancearray">InstanceArray</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#tu-pian-yu-wen-ben-hui-zhi">图片与文本绘制</a>
                    
                    <ol class="toc-child">
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#tu-pian-hui-zhi">图片绘制</a>
                        </li>
                        
                        <li class="toc-item toc-level-2">
                            <a href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#wen-ben-hui-zhi">文本绘制</a>
                        </li>
                        
                    </ol>
                    
                </li>
                
                <li class="toc-item toc-level-1">
                    <a class="toc-link" href="https://zhen.wang/article/基于Rust的Tile-Based游戏开发杂记（02）ggez绘图实操/#xie-zai-zui-hou">写在最后</a>
                    
                </li>
                
            </ol>
        </div>
    </div>
    
    <!-- real content -->
    <div class="article-content markdown-content">
        <p>尽管ggez提供了很多相关特性的<a rel="noopener" target="_blank" href="https://github.com/ggez/ggez/tree/master/examples">demo</a>供运行查看，但笔者第一次使用的时候还是有很多疑惑不解。经过仔细阅读demo代码并结合自己的实践，逐步了解了ggez在不同场景下的绘图方式，在此篇文章进行一定的总结，希望能够帮助到使用ggez的读者。</p>
<span id="continue-reading"></span><h1 id="ji-ben-mo-shi">基本模式</h1>
<p>在ggez官方文档中提到一个核心的功能就是基于wgpu图形API的硬件加速的2D渲染：</p>
<blockquote>
<p>Hardware-accelerated 2D rendering built on the wgpu graphics API</p>
</blockquote>
<p>ggez的基础绘制模式一般分为3步：</p>
<ol>
<li>在每一次绘图事件回调中，通过图形上下文构造一个ggez封装的画布Canvas实例；</li>
<li>调用画布的<code>draw</code>方法，传入想要绘制的图形（例如一个矩形、一个圆）和相关绘图参数（位置、大小缩放等变换）；</li>
<li>完成所有图像绘制后，调用画布的<code>finish</code>方法，向底层图形模块进行一次绘图提交，进而触发底层将最终渲染的图像呈现到画布区域上。</li>
</ol>
<p>从代码的角度来看，大致如下：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>MyState {}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>EventHandler </span><span style="color:#b48ead;">for </span><span>MyState {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">update</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">_ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">///
</span><span>    </span><span style="color:#65737e;">/// 绘图
</span><span>    </span><span style="color:#65737e;">///
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">// 1. 构造canvas实例
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> canvas =
</span><span>            graphics::Canvas::from_frame(ctx, graphics::Color::from([</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>]));
</span><span>
</span><span>        </span><span style="color:#65737e;">// 2. 绘图
</span><span>   			</span><span style="color:#65737e;">// ... ...
</span><span>
</span><span>        </span><span style="color:#65737e;">// 3. finish
</span><span>        canvas.</span><span style="color:#96b5b4;">finish</span><span>(ctx)?;
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span></code></pre>
<p>注释中步骤1、3的代码一般来说都很固定，读者根据注释应该很容易理解，这里不再赘述，接下来我们重点关注具体的图形绘制代码。</p>
<h1 id="jian-dan-hui-zhi-yi-ge-ju-xing">简单绘制一个矩形</h1>
<p>当我们希望在窗口上左上角<code>(10, 20)</code>的位置绘制一个<code>40 x 50</code>的红色矩形时，我们可以通过编写如下的代码来完成：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">// 1. 构造canvas实例
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> canvas =
</span><span>            graphics::Canvas::from_frame(ctx, graphics::Color::from([</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>]));
</span><span>
</span><span>        </span><span style="color:#65737e;">// 2. 绘图
</span><span>        </span><span style="color:#b48ead;">let</span><span> draw_param = DrawParam::new()
</span><span>      			.</span><span style="color:#96b5b4;">color</span><span>(Color::new(</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>))
</span><span>            .</span><span style="color:#96b5b4;">dest</span><span>(Point2::from([</span><span style="color:#d08770;">10.</span><span>, </span><span style="color:#d08770;">20.</span><span>]))
</span><span>            .</span><span style="color:#96b5b4;">scale</span><span>(Point2::from([</span><span style="color:#d08770;">40.</span><span>, </span><span style="color:#d08770;">50.</span><span>]));
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;Quad, draw_param);
</span><span>
</span><span>        </span><span style="color:#65737e;">// 3. finish
</span><span>        canvas.</span><span style="color:#96b5b4;">finish</span><span>(ctx)?;
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<blockquote>
<p>本文将在接下来的内容中逐步介绍不同场景下的绘制，主要会更改关于上述代码中<code>fn draw</code>中的内容，其余基本不会改变，所以后续的代码片段没有特殊说明的情况下，均只会贴出<code>fn draw</code>中的内容。</p>
</blockquote>
<p>我们首先构造一个<code>DrawParam</code>实例，通过它来描述我们最终期望绘制的图形的位置和大小。其中，<code>.color()</code>不难理解即配置颜色；<code>dest</code>指绘制的目标位置；最后，我们定义绘制的矩形的尺寸，但这里值得注意的是，API提供的是<code>scale</code>（中文译为“缩放”），并不是一个类似于<code>size</code>名称的API，对于初学者来说，这其实是有点反直觉的，别着急，我们稍后就来解释这个地方的概念。</p>
<p>接下来，调用<code>draw</code>时，我们第一参数传给的是一个<code>Quad</code>实例（的引用），第二个参数就是<code>DrawParam</code>数据。这个<code>Quad</code>是什么？通过查看源码文档，我们了解到<code>Quad</code>是ggez内置的一个最基础的<code>1 x 1</code>的Mesh（图形学中一般译为“网格”）：</p>
<blockquote>
<p>A Drawable unit type that maps to a simple 1x1 quad mesh.
一种可绘制的单元类型,映射到简单的1x1四方网格。</p>
</blockquote>
<p>这里，我们不深究<code>Quad</code>这个1 x 1的mesh网格在计算机图形学中的意义，先简单将其理解为一个1 x 1的小方块。那么我们再回看之前提到的<code>DrawParam::scale</code>，该API指定的是<code>Quad</code>的缩放比例，也就是说，当我们代码中边写的是<code>scale([40., 50.])</code>的时候，实际上就是希望将一个原本1 x 1的矩形，使其宽扩大40倍，高扩大50倍。</p>
<blockquote>
<p>为什么要使用缩放而不是直观的定义尺寸？这涉及到图形学中的变换，我们暂时不在本文中深究。</p>
</blockquote>
<h1 id="fu-za-tu-xing">复杂图形</h1>
<p>前面的<code>Quad</code>读者可以理解为只是ggez内置的一个极为简单的mesh“模板”，通过它我们能在画布指定位置绘制一个指定大小且纯色的矩形块。但实际上，我们在绘图的过程中必然不可能只会画这些简单的方块，或多或少都会画一些不同形状的几何，譬如圆、椭圆、三角形等，以及我们可能还需要为这些几何图形实现渐变，增加边框等效果。作为一款支持2D渲染的游戏框架，这部分的能力当然不会缺失。接下来我们继续介绍ggez在复杂图形的绘图方面的内容。</p>
<h2 id="mesh">Mesh</h2>
<p>在ggez中，提供了图形学知识体系中的Mesh数据结构，它是一份包含顶点数据缓存、索引数据缓存，并可以存储在GPU上的数据，并且通过文档我们了解到它的克隆复制成本很低。</p>
<blockquote>
<p>Mesh data stored on the GPU as a vertex and index buffer. Cheap to clone.</p>
</blockquote>
<p>关于Mesh的数据结构的含义，如果读者没有学习过计算机图形学，理解起来可能有困难。但在这里，我们可以暂时将它理解为想要通过GPU帮助我们绘图时，提供的一份较为底层的，GPU能直接使用的数据。比如，我们想要画一个矩形，从应用层面的角度，我们可能会定义一个数据结构叫<code>Rect</code>，它包含如下的信息：</p>
<ol>
<li>位置（position）</li>
<li>宽高（width和height）</li>
<li>颜色（color）</li>
</ol>
<p>但是GPU绘图的时候，我们需要将这些信息转换为GPU能够使用的，更为底层的数据，可能是四个顶点、颜色等数据。</p>
<p>那么，在ggez库中应该如何创建一份Mesh数据呢？以创建一个圆为例，通过阅读文档，我们可以使用<code>Mesh::new_circle</code>方法得到：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> circle_mesh = Mesh::new_circle(
</span><span>    ctx, </span><span style="color:#65737e;">// ctx: &amp;mut Context
</span><span>    Fill(FillOptions::default()), </span><span style="color:#65737e;">// 填充模式
</span><span>    [</span><span style="color:#d08770;">50.</span><span>, </span><span style="color:#d08770;">50.</span><span>], </span><span style="color:#65737e;">// 圆心
</span><span>    </span><span style="color:#d08770;">25.</span><span>, </span><span style="color:#65737e;">// 半径
</span><span>    </span><span style="color:#d08770;">0.01</span><span>, </span><span style="color:#65737e;">// 绘制圆弧曲线时多边形长度，越小越圆。
</span><span>    Color::from_rgb(</span><span style="color:#d08770;">255</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#65737e;">// 颜色
</span><span>)
</span></code></pre>
<p>该方法的入参也非常容易理解，就是一些绘制圆形的基本配置（半径、颜色等）。通过该方法构造一个Mesh后，我们就可以按照之前的方式，通过调用<code>canvas.draw</code>方法来绘制它：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> circle_mesh = Mesh::new_circle(
</span><span>    ctx,
</span><span>    Fill(FillOptions::default()),
</span><span>    [</span><span style="color:#d08770;">50.</span><span>, </span><span style="color:#d08770;">50.</span><span>],
</span><span>    </span><span style="color:#d08770;">25.</span><span>,
</span><span>    </span><span style="color:#d08770;">0.001</span><span>,
</span><span>    Color::from_rgb(</span><span style="color:#d08770;">255</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>)
</span><span>)?;
</span><span style="color:#b48ead;">let</span><span> draw_param = DrawParam::default()
</span><span>    .</span><span style="color:#96b5b4;">dest</span><span>(Point2::from([</span><span style="color:#d08770;">100.</span><span>, </span><span style="color:#d08770;">100.</span><span>]))
</span><span>    .</span><span style="color:#96b5b4;">scale</span><span>(Point2::from([</span><span style="color:#d08770;">1.</span><span>, </span><span style="color:#d08770;">1.</span><span>]))
</span><span>    .</span><span style="color:#96b5b4;">color</span><span>(Color::new(</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>));
</span><span>canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;circle_mesh, draw_param);
</span><span>Ok(())
</span></code></pre>
<p>看到这段代码，细心的读者会立刻发现，我们已经定义了圆心的位置<code>[50.0, 50.0]</code>，但是在构造<code>DrawParam</code>数据的时候，又定义了一个：<code>.dest(Point2::from([100., 100.]))</code>，即我们希望将图形绘制到<code>(100, 100)</code>这个位置，很明显这二者是有冲突的。所以实际是什么结果呢？这里直接给出结论：<strong>图形的最终位置为图形的自身位置 “叠加” <code>DrawParam</code>的位置配置</strong>。所以，上述代码中最终圆所处的位置为<code>(150, 150)</code>坐标处。</p>
<p>再来讨论<code>.scale(Point2::from([1., 1.]))</code>代码的意义。这里我们知道是对图形进行尺寸缩放，在水平和垂直方向上均缩放1.0倍，也就是说不改变图形原有大小。如果我们希望对这个图形在水平方向（x轴）上放大2倍，垂直方向不变，就可以通过scale参数来定制：<code>.scale(Point2::from([2., 1.]))</code>。</p>
<p>最后是<code> .color(Color::new(0.0, 1.0, 0.0, 1.0));</code>。通过该API，我们定义了图形在绘制的时候使用绿色。很显然，和前面我们构造<code>circle_mesh</code>指定的红色（<code>Color::from_rgb(255, 0, 0)</code>）是不一致的。**这里最终的结果也是一种叠加，但是它们的叠加不是简单的加减，而是每一单色的值的相乘。**也就是说，按照上面的代码，最终：<code>Red=255 * 0.0 = 0</code>，<code>Green = 0 * 1.0</code>，<code>Blue = 0 * 1.0 = 0</code>，运行以后，你会发现显示出来的是一个黑色圆形！如果你不配置<code>DrawParam</code>的<code>color</code>，它默认是白色（<code>[1.0, 1.0, 1.0, 1.0]</code>），此时，按照相乘的结果，就始终等于你图形定义的颜色了。</p>
<p>下图是一个综合上述讲解后的一个图形：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/010-draw-circle.png" alt="010-draw-circle" /></p>
<p>此外，<code>DrawParam</code>还有诸如<code>rotation（旋转）</code>、<code>offset（偏移）</code>等配置，但是通过阅读底层代码，我们会发现<code>DrawParam</code>关于图形位置、缩放等数据核心其实是通过<code>变换transform</code>这个字段数据存储的：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">/// DrawParam源码数据结构
</span><span style="color:#b48ead;">pub struct </span><span>DrawParam {
</span><span>    </span><span style="color:#65737e;">/// A portion of the drawable to clip, as a fraction of the whole image.
</span><span>    </span><span style="color:#65737e;">/// Defaults to the whole image (\[0.0, 0.0\] to \[1.0, 1.0\]) if omitted.
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">src</span><span>: Rect,
</span><span>    </span><span style="color:#65737e;">/// Default: white.
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">color</span><span>: Color,
</span><span>    </span><span style="color:#65737e;">/// Where to put the object.
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">transform</span><span>: Transform, </span><span style="color:#65737e;">// &lt;- 变换是核心
</span><span>    </span><span style="color:#65737e;">/// The Z coordinate of the draw.
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">z</span><span>: ZIndex,
</span><span>}
</span></code></pre>
<p>至于变换transform，如果学习过图形学、线代、向量等知识理解起来应该完全没有难度。</p>
<blockquote>
<p>DrawParam的其他参数：<code>pub src: Rect</code>、<code>pub z: ZIndex,</code>我们会在后面实践并解释。</p>
</blockquote>
<p>目前为止，我们大致了解了图形绘制的两个部分：1、图形Mesh数据；2、DrawParam绘制定义数据。通过实践我们也了解了它们二者会有定义重叠的部分（例如位置、颜色等）以及叠加的方式。那么，当我们实际开发的时候，面对重叠的部分，究竟是通过配置Mesh本身还是DrawParam呢？要回答这个问题，我们首先要了解一份Mesh数据创建以后，它能做什么。通过阅读文档，我们发现Mesh数据在创建以后，仅仅是提供了一些克隆等API，也就是说，一旦Mesh数据构造完成，就无法对颜色、位置数据进行二次加工设置。而DrawParam数据很容易修改位置、大小、颜色等。也就是说，Mesh数据更偏向于静态绘图，而DrawParam主要负责可变化的绘制。如果在你的场景中，存在对一些图形按照每帧在不同的位置，呈现不同的颜色，那么笔者更建议创建一份图形的Mesh数据，然后在每帧绘制阶段通过临时构造DrawParam来制定当前帧的绘制情况。</p>
<p>举例来说，比如我想在窗体中绘制一个圆形，随着每帧从左到右移动，并且颜色随着从左到右从黑色变成红色：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/020-draw-dynamic-circle.gif" alt="020-draw-dynamic-circle" /></p>
<p>为了达到这样的效果，最直观的做法是我们可以在每一次<code>fn draw</code>调用的时候，构造一份对应时刻的对应颜色的圆形的Mesh实例，并进行绘制。但是性能和资源利用更好的方式则是提前创建一份Mesh数据，并在每一次draw调用时，只改变DrawParam的参数即可：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/030-draw-dynamic-circle-code.png" alt="030-draw-dynamic-circle-code" /></p>
<h2 id="meshbuilderyu-meshdata">MeshBuilder与MeshData</h2>
<p>尽管比起之前的<code>Qaud</code>图形，我们现在已经能够绘制圆、三角形、多边形等更多种类的图形，但总的来说依然是一些常见的几何图形，对于实际的应用场景可能还远远不够。比如说，我们希望绘制一座房子，大概像下图这样：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/040-house-draft.png" alt="040-house-draft" /></p>
<p>我们将这个图形分解为三个部分：顶部使用一个棕色三角形作为房顶，房顶下方使用一个黄色矩形作为房屋体，在房屋体内部使用一个棕色的矩形作为门。按照之前的方式，我们首先构造mesh：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/050-multi-mesh-a-house.png" alt="050-multi-mesh-a-house" /></p>
<p>在这段代码中，我们首先在DrawHouseState结构体中增加了3个mesh数据字段：<code>roof</code>（屋顶）、<code>house_body</code>（房屋体）、<code>door</code>（门），在初始化阶段我们构造这三部分并存储起来。</p>
<p>接下来是绘制阶段代码：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">// 1. 构造canvas实例
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> canvas =
</span><span>            graphics::Canvas::from_frame(ctx, graphics::Color::from([</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>]));
</span><span>
</span><span>      	</span><span style="color:#65737e;">// 2. draw调用了3次！
</span><span>        </span><span style="color:#b48ead;">let</span><span> draw_param = DrawParam::default()
</span><span>            .</span><span style="color:#96b5b4;">dest</span><span>(Point2::from([</span><span style="color:#d08770;">100.</span><span>, </span><span style="color:#d08770;">100.</span><span>]))
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.roof, draw_param.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.house_body, draw_param.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.door, draw_param.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>
</span><span>        </span><span style="color:#65737e;">// 3. finish
</span><span>        canvas.</span><span style="color:#96b5b4;">finish</span><span>(ctx)?;
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<p>在绘制阶段，我们定义了一份DrawParam数据，同时分别对<code>roof</code>、<code>house_body</code>以及<code>door</code>进行绘制。这段代码运行后的效果如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/060-house-result1.png" alt="060-house-result1" /></p>
<p>上述代码并不复杂，相信读者能够理解。但是这样的方式并不优雅，因为随着图形结构复杂度愈来越高，我们不可能随时关注一大堆的mesh实例；此外，这样的方式还有一个问题：为了绘制一个“房子”，我们调用了3次<code>canvas.draw</code>方法，会有性能上的问题（后续会量化）。</p>
<p>为了解决上述问题，ggez为我们提供了<code>MeshBuilder</code>。通过<code>MeshBuilder</code>，我们可以将多个mesh同时组合得到一份整体的mesh数据：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/070-single-mesh-a-house.png" alt="070-single-mesh-a-house" /></p>
<p>上面的代码，就是通过<code>MeshBuilder</code>依次构造了一个三角形、两个矩形。<code>MeshBuilder</code>最后的<code>build</code>方法会返回一个<code>MeshData</code>，请注意，这的MeshData结构体并不是前面的Mesh数据，而是Mesh结构体创建的来源数据，我们可以将<code>MeshData</code>实例传递给<code>Mesh::from_data</code>方法来创建Mesh。于是，此处我们只通过一个mesh就包含了整个房屋的图形数据。</p>
<p>最后，在渲染的时候，我们只需要调用<code>canvas.draw</code>一次：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">// 1. 构造canvas实例
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> canvas =
</span><span>            graphics::Canvas::from_frame(ctx, graphics::Color::from([</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>]));
</span><span>
</span><span>        </span><span style="color:#65737e;">// 2. DrawParam和绘制一次
</span><span>        </span><span style="color:#b48ead;">let</span><span> draw_param = DrawParam::default()
</span><span>            .</span><span style="color:#96b5b4;">dest</span><span>(Point2::from([</span><span style="color:#d08770;">100.</span><span>, </span><span style="color:#d08770;">100.</span><span>]));
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.house, draw_param.</span><span style="color:#96b5b4;">clone</span><span>());
</span><span>
</span><span>        </span><span style="color:#65737e;">// 3. finish
</span><span>        canvas.</span><span style="color:#96b5b4;">finish</span><span>(ctx)?;
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<h2 id="instancearray">InstanceArray</h2>
<p>理论上来讲，MeshBuilder提供了将基础图形构成复杂图形以及方便对其进行整体操作的能力。但还有一个场景我们需要进一步讨论：**如何绘制大量的图形？**有的读者可能会说，那好办，在绘图的时候，一个for循环，多次调用<code>canvas.draw</code>绘制大量的图形：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/080-draw-house-for400.png" alt="080-draw-house-for400" /></p>
<p>上述的代码，我们通过两个for循环共计400次，依次在<code>(0, 0)</code>、<code>(0, 50)</code>等位置绘制了50x50的正方形，将原来的房子绘制到对应区域。其中，缩放代码<code>let scale = [SIZE / 100., SIZE / 100.];</code>含义是我们的房子本身的尺寸是宽100，高100的尺寸，为了将其刚好会知道50x50的区域内，就需要按照比例缩放：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/090-house-scale.png" alt="090-house-scale" /></p>
<p>上述的代码最终运行的效果如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/100-draw-house-for400-result.png" alt="100-draw-house-for400-result" /></p>
<p>从代码逻辑的角度上讲使用for循环还算过得去，但是从性能层面上却有很大的问题。在这里为了可视化性能，我们使用ggez提供的API获得整个应用在运行过程中的fps均值，以此粗略地估算应用在每一次刷新时的性能情况：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>EventHandler </span><span style="color:#b48ead;">for </span><span>DrawMultiHouseState {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">update</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">_ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        println!(&quot;</span><span style="color:#a3be8c;">game fps: </span><span style="color:#d08770;">{:?}</span><span>&quot;, _ctx.time.</span><span style="color:#96b5b4;">fps</span><span>());
</span><span>        Ok(())
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>				</span><span style="color:#65737e;">// ... ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>上述的代码，我们在每一次update中，向控制台打印当前应用的fps值。可以看到在笔者的机器上，未经过编译优化的代码，将这400个小房子绘制到屏幕上，平均的fps在<strong>12</strong>左右：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/110-low-fps.png" alt="110-low-fps" /></p>
<p>对于游戏来说，这么简单的绘制400个图形fps就这么低显然是不应该的。那么这里的最佳实践是什么呢？答案是使用ggez提供的<code>InstanceArray</code>。该<code>InstanceArray</code>可以用来一次性存储大量的DrawParam数据。当我们要绘制400个房子的时候，实际上只需要构造400个DrawParam，将它们存放到<code>InstanceArray</code>中，这400个DrawParam，每一个的<code>dest</code>参数都不同，用来表示400个房子的不同位置。当我们需要进行绘制的时候，只需要调用一次<code>canvas.draw_instanced_mesh</code>方法，将<code>InstanceArray</code>作为第二个参数传入，即可在屏幕上呈现这400个房子，而不是循环400次，每次draw一次：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/120-draw-house-by-instance-arr-code.png" alt="120-draw-house-by-instance-arr-code" /></p>
<blockquote>
<p>核心本质是每调用一次draw，就是数据从内存到GPU的一次数据传输。</p>
</blockquote>
<p>通过使用<code>InstanceArray</code>，在同样的编译条件下，在本人60hz刷新率的机器上，绘制这400个图形的fps均值直接拉满60帧：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/130-full-fps.png" alt="130-full-fps" /></p>
<h1 id="tu-pian-yu-wen-ben-hui-zhi">图片与文本绘制</h1>
<p>实际上，图片与文本绘制的模式大体上和前面的图形绘制是保持一致的，都是首先创建一个被绘制的实例：</p>
<ul>
<li>图片：<code>ggez::graphics::Image</code></li>
<li>文本：<code>ggez::graphics::Text</code></li>
</ul>
<p>然后构造<code>DrawParam</code>实例或是存放<code>DrawParam</code>的<code>InstanceArray</code>实例；最后调用<code>canvas.draw</code>或<code>canvas.draw_instanced_mesh</code>完成单个或批量绘制。接下来我们分别介绍一下ggez绘制图片数据和文本的具体实践。</p>
<h2 id="tu-pian-hui-zhi">图片绘制</h2>
<p>如果是对矮人要塞或是CDDA大灾变等Tile-Based游戏深入了解过，就会发现，这些游戏的图形通常不是一张又一张的小图片存放起来，而是使用一张NxN规格的图片，把所有的图块统一铺在上面的：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/140-tile-img-in-picture.png" alt="140-tile-img-in-picture" /></p>
<p>例如，上图是矮人要塞的Spacefox图块集。你会发现游戏中所有的图形元素都按照16x16的大小统一集中到了这张图片上。那么在实际运行中是如何渲染的呢？游戏只需要将这一张图片加载到内存中，当想要渲染一个“包裹”（上图的第一行倒数第五个就是“包裹”）图形的时候，只需要提供区域偏移信息即可只绘制。</p>
<p>当然，我们先介绍基础图片绘制的方式，将上述一整张图片绘制到窗体上。首先，我们需要加载图片：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span>DrawImageState {
</span><span>    </span><span style="color:#bf616a;">image</span><span>: graphics::Image,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>DrawImageState {
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; GameResult&lt;</span><span style="color:#b48ead;">Self</span><span>&gt; {
</span><span>        </span><span style="color:#65737e;">/// 使用该路径前，请手动将&quot;spacefox_16x16.png&quot;复制到
</span><span>        </span><span style="color:#65737e;">/// 编译的生成的target/debug/resources目录下（没有请手动创建）
</span><span>        </span><span style="color:#b48ead;">let</span><span> image = graphics::Image::from_path(ctx, &quot;</span><span style="color:#a3be8c;">/spacefox_16x16.png</span><span>&quot;)?;
</span><span>        Ok(DrawImageState { image })
</span><span>    }
</span><span>}
</span></code></pre>
<p>上述代码在State结构体中定义了一个image字段，用于存放<code>ggez::graphics::Image</code>实例；在初始化代码中，我们通过调用<code>graphics::Image::from_path</code>来读取图片<code>spacefox_16x16.png</code>。**默认情况下，**图片的搜索目录会从可执行程序所在目录下的<code>resources</code>目录中查找。所以为了后续正常运行，我们先暂时手动将图片拷贝至对应目录：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/150-copy-image.png" alt="150-copy-image" /></p>
<blockquote>
<p>关于ggez中的文件系统，后续会有文章详细讲解。</p>
</blockquote>
<p>图片的加载和存储准备好以后，我们在绘图阶段编写如下代码：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>   </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">// 1. 构造canvas实例
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> canvas =
</span><span>            graphics::Canvas::from_frame(ctx, graphics::Color::from([</span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>, </span><span style="color:#d08770;">1.0</span><span>]));
</span><span>
</span><span>        </span><span style="color:#65737e;">// 2. 绘制图片到指定位置
</span><span>        </span><span style="color:#b48ead;">let</span><span> dest_point = Vec2::new(</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>);
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.image, DrawParam::new().</span><span style="color:#96b5b4;">dest</span><span>(dest_point));
</span><span>
</span><span>        </span><span style="color:#65737e;">// 3. finish
</span><span>        canvas.</span><span style="color:#96b5b4;">finish</span><span>(ctx)?;
</span><span>        Ok(())
</span><span>    }
</span></code></pre>
<p>在实际运行以后，我们能够看到如下效果：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/160-draw-full-image.png" alt="160-draw-full-image" /></p>
<p>接下来，我们该如何将图片局部绘制到界面上？答案就是使用DrawParam的<code>src</code>参数来进行配置。首先，为了绘制上图第一行倒数第5个“包裹”图形，我们首先要确定它处于整张图片的哪个位置。已知图片尺寸为256x256像素，每一个图块尺寸为16x16，“包裹”图块处于水平第12个（基于0索引就是11），垂直第1个（基于0索引就是0）。所以，我们知道“包裹”所在的矩形区域为<code>x = 11 * 16, y = 0 * 16, w = 16, h = 16</code>：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/170-tile-rect.png" alt="170-tile-rect" /></p>
<p>于是，我们创建对应区域数据，并作为参数传递给DrawParam：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">draw</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">ctx</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> Context) -&gt; Result&lt;(), GameError&gt; {
</span><span>        </span><span style="color:#65737e;">/// ... ...
</span><span>      
</span><span>        </span><span style="color:#65737e;">// 2. 绘制图片到指定位置
</span><span>        </span><span style="color:#b48ead;">const </span><span style="color:#d08770;">TILE_SIZE</span><span>: </span><span style="color:#b48ead;">f32 </span><span>= </span><span style="color:#d08770;">16.</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> src_rect = Rect::new(</span><span style="color:#d08770;">11. </span><span>* </span><span style="color:#d08770;">TILE_SIZE</span><span>, </span><span style="color:#d08770;">0. </span><span>* </span><span style="color:#d08770;">TILE_SIZE</span><span>, </span><span style="color:#d08770;">TILE_SIZE</span><span>, </span><span style="color:#d08770;">TILE_SIZE</span><span>);
</span><span>        canvas.</span><span style="color:#96b5b4;">draw</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>.image, DrawParam::new().</span><span style="color:#96b5b4;">src</span><span>(src_rect).</span><span style="color:#96b5b4;">dest</span><span>(Vec2::new(</span><span style="color:#d08770;">0.0</span><span>, </span><span style="color:#d08770;">0.0</span><span>)));
</span><span>      
</span><span> 				</span><span style="color:#65737e;">/// ... ...
</span><span>    }
</span></code></pre>
<p>初看这段代码，应该很好理解，但在实际运行后笔者会发现显示的很有问题。其实，核心原因是ggez中关于<code>DrawParam::src</code>所需要的矩形数据是一个相对的数据，它的注释如下：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, Copy, Clone, PartialEq)]
</span><span style="color:#b48ead;">pub struct </span><span>DrawParam {
</span><span>    </span><span style="color:#65737e;">/// A portion of the drawable to clip, as a fraction of the whole image.
</span><span>    </span><span style="color:#65737e;">/// Defaults to the whole image (\[0.0, 0.0\] to \[1.0, 1.0\]) if omitted.
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">src</span><span>: Rect,
</span><span>    </span><span style="color:#65737e;">/// ... ...
</span><span>}
</span></code></pre>
<p>这段注释指的是：传入的Rect矩形的x、y、w、h都是相对于整张图片的相对值，其值范围是0.0到1.0之间的。回到我们的例子，“包裹”图块的对于整张图片的实际位置和尺寸数据是：<code>x = 11 * 16, y = 0 * 16, w = 16, h = 16</code>，那么x相对于整张图片是：<code>(11 * 16) / 水平宽度256</code>，y相对于图片水平是：<code>(0 * 16) / 水平高度256</code>，宽度w相对于整张图是<code>16 / 256</code>，高度h相对于整张图是<code>16 / 256</code>。所以我们需要做如下的转换处理才能正确绘制：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/180-tile-ratio-rect.png" alt="180-tile-ratio-rect" /></p>
<p>修正代码以后，我们能看到实际的运行效果：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/190-draw-part-image.png" alt="190-draw-part-image" /></p>
<h2 id="wen-ben-hui-zhi">文本绘制</h2>
<p>使用ggez绘制文本，离不开两个重要的结构体：<code>ggez::graphics::Text</code>、<code>ggez::graphics::TextFragment</code>。其中，<code>Text</code>是被绘制的数据，而<code>TextFragment</code>主要用于定义一段文本中的局部结构，可以作为<code>Text</code>的参数：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/200-draw-text.png" alt="200-draw-text" /></p>
<p>上述的代码，我们首先使用<code>Text::new("hello, world.")</code>在画布上绘制文本：<code>"hello, world."</code>；然后，我们使用<code>TextFragment</code>构建了个两个片段：</p>
<ol>
<li><code>TextFragment::new("RED").color(Color::RED)</code></li>
<li><code>TextFragment::new("BLUE").color(Color::BLUE)</code></li>
</ol>
<p>然后通过它们构造了一个新的<code>Text</code>实例。这部分的含义是希望绘制的一段文本，<code>"RED"</code>使用红色绘制，<code>"BLUE"</code>使用蓝色绘制。</p>
<p>上述代码的最终效果如下：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/210-draw-text-display.png" alt="210-draw-text-display" /></p>
<h1 id="xie-zai-zui-hou">写在最后</h1>
<p>本文主要介绍了使用ggez的图形部分API进行一些基础图形、图片以及文本绘制。尽管ggez在官方提到图形渲染部分是基于<code>wgpu</code>的硬件加速的<strong>2D</strong>图形渲染：</p>
<blockquote>
<ul>
<li>Hardware-accelerated 2D rendering built on the <code>wgpu</code> graphics API</li>
</ul>
</blockquote>
<p>但由于ggez底层使用了<code>wgpu</code>，同时也通过一定方式暴露了<code>wgpu</code>的相关API，所以实际上我们依然可以进行利用<code>wgpu</code>进行3D图形绘制，不过这部分内容需要读者有相关3D图形渲染理论知识以及相关图形库API的使用经验，就不在本文中描述了，笔者可以通过官方<a href="https://zhen.wang/article/%E5%9F%BA%E4%BA%8ERust%E7%9A%84Tile-Based%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%9D%82%E8%AE%B0%EF%BC%8802%EF%BC%89ggez%E7%BB%98%E5%9B%BE%E5%AE%9E%E6%93%8D/%5Bgithub.com/ggez/ggez/blob/master/examples/cube.rs%5D(https://github.com/ggez/ggez/blob/master/examples/cube.rs)">样例代码</a>一探究竟：</p>
<p><img src="https://static-res.zhen.wang/images/post/2024-03-16/220-3d-cube.gif" alt="220-3d-cube" /></p>
<p>本章代码仓库地址：<a rel="noopener" target="_blank" href="https://github.com/w4ngzhen/rs-game-dev">w4ngzhen/rs-game-dev (github.com)</a></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>cargo run --package chapter_02
</span></code></pre>

    </div>
</div>
<script src="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.js"></script>
<link rel="stylesheet" href="https://zhen.wang/libs/viewerjs@1.11.7/viewer.min.css"/>
<script>
  if (window.Viewer) {
    document.querySelectorAll('img').forEach(img => {
      new Viewer(img, {
        inline: false,
        navbar: false,
        toolbar: {
          zoomIn: 1,
          zoomOut: 1,
          reset: 1,
          rotateLeft: 1,
          rotateRight: 1,
        },
      });
    });
  }
</script>


</body>
</html>